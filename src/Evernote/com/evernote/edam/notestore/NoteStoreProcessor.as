/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.evernote.edam.notestore {

import org.apache.thrift.Set;
import org.apache.thrift.type.BigInteger;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

import com.evernote.edam.error.EDAMUserException;
import com.evernote.edam.error.EDAMSystemException;
import com.evernote.edam.notestore.SyncChunkFilter;
import com.evernote.edam.type.LinkedNotebook;
import com.evernote.edam.error.EDAMNotFoundException;
import com.evernote.edam.type.Notebook;
import com.evernote.edam.type.Tag;
import com.evernote.edam.type.SavedSearch;
import com.evernote.edam.notestore.NoteFilter;
import com.evernote.edam.notestore.NotesMetadataResultSpec;
import com.evernote.edam.type.LazyMap;
import com.evernote.edam.type.Note;
import com.evernote.edam.type.Resource;
import com.evernote.edam.type.ResourceAttributes;
import com.evernote.edam.notestore.AdParameters;
import com.evernote.edam.type.Ad;
import com.evernote.edam.type.SharedNotebook;
import com.evernote.edam.userstore.AuthenticationResult;
import com.evernote.edam.notestore.NoteEmailParameters;

  public class NoteStoreProcessor implements TProcessor {
    public function NoteStoreProcessor(iface:NoteStore)
    {
      iface_ = iface;
      PROCESS_MAP["getSyncState"] = getSyncState();
      PROCESS_MAP["getSyncChunk"] = getSyncChunk();
      PROCESS_MAP["getFilteredSyncChunk"] = getFilteredSyncChunk();
      PROCESS_MAP["getLinkedNotebookSyncState"] = getLinkedNotebookSyncState();
      PROCESS_MAP["getLinkedNotebookSyncChunk"] = getLinkedNotebookSyncChunk();
      PROCESS_MAP["listNotebooks"] = listNotebooks();
      PROCESS_MAP["getNotebook"] = getNotebook();
      PROCESS_MAP["getDefaultNotebook"] = getDefaultNotebook();
      PROCESS_MAP["createNotebook"] = createNotebook();
      PROCESS_MAP["updateNotebook"] = updateNotebook();
      PROCESS_MAP["expungeNotebook"] = expungeNotebook();
      PROCESS_MAP["listTags"] = listTags();
      PROCESS_MAP["listTagsByNotebook"] = listTagsByNotebook();
      PROCESS_MAP["getTag"] = getTag();
      PROCESS_MAP["createTag"] = createTag();
      PROCESS_MAP["updateTag"] = updateTag();
      PROCESS_MAP["untagAll"] = untagAll();
      PROCESS_MAP["expungeTag"] = expungeTag();
      PROCESS_MAP["listSearches"] = listSearches();
      PROCESS_MAP["getSearch"] = getSearch();
      PROCESS_MAP["createSearch"] = createSearch();
      PROCESS_MAP["updateSearch"] = updateSearch();
      PROCESS_MAP["expungeSearch"] = expungeSearch();
      PROCESS_MAP["findNotes"] = findNotes();
      PROCESS_MAP["findNoteOffset"] = findNoteOffset();
      PROCESS_MAP["findNotesMetadata"] = findNotesMetadata();
      PROCESS_MAP["findNoteCounts"] = findNoteCounts();
      PROCESS_MAP["getNote"] = getNote();
      PROCESS_MAP["getNoteApplicationData"] = getNoteApplicationData();
      PROCESS_MAP["getNoteApplicationDataEntry"] = getNoteApplicationDataEntry();
      PROCESS_MAP["setNoteApplicationDataEntry"] = setNoteApplicationDataEntry();
      PROCESS_MAP["unsetNoteApplicationDataEntry"] = unsetNoteApplicationDataEntry();
      PROCESS_MAP["getNoteContent"] = getNoteContent();
      PROCESS_MAP["getNoteSearchText"] = getNoteSearchText();
      PROCESS_MAP["getResourceSearchText"] = getResourceSearchText();
      PROCESS_MAP["getNoteTagNames"] = getNoteTagNames();
      PROCESS_MAP["createNote"] = createNote();
      PROCESS_MAP["updateNote"] = updateNote();
      PROCESS_MAP["deleteNote"] = deleteNote();
      PROCESS_MAP["expungeNote"] = expungeNote();
      PROCESS_MAP["expungeNotes"] = expungeNotes();
      PROCESS_MAP["expungeInactiveNotes"] = expungeInactiveNotes();
      PROCESS_MAP["copyNote"] = copyNote();
      PROCESS_MAP["listNoteVersions"] = listNoteVersions();
      PROCESS_MAP["getNoteVersion"] = getNoteVersion();
      PROCESS_MAP["getResource"] = getResource();
      PROCESS_MAP["getResourceApplicationData"] = getResourceApplicationData();
      PROCESS_MAP["getResourceApplicationDataEntry"] = getResourceApplicationDataEntry();
      PROCESS_MAP["setResourceApplicationDataEntry"] = setResourceApplicationDataEntry();
      PROCESS_MAP["unsetResourceApplicationDataEntry"] = unsetResourceApplicationDataEntry();
      PROCESS_MAP["updateResource"] = updateResource();
      PROCESS_MAP["getResourceData"] = getResourceData();
      PROCESS_MAP["getResourceByHash"] = getResourceByHash();
      PROCESS_MAP["getResourceRecognition"] = getResourceRecognition();
      PROCESS_MAP["getResourceAlternateData"] = getResourceAlternateData();
      PROCESS_MAP["getResourceAttributes"] = getResourceAttributes();
      PROCESS_MAP["getAccountSize"] = getAccountSize();
      PROCESS_MAP["getAds"] = getAds();
      PROCESS_MAP["getRandomAd"] = getRandomAd();
      PROCESS_MAP["getPublicNotebook"] = getPublicNotebook();
      PROCESS_MAP["createSharedNotebook"] = createSharedNotebook();
      PROCESS_MAP["sendMessageToSharedNotebookMembers"] = sendMessageToSharedNotebookMembers();
      PROCESS_MAP["listSharedNotebooks"] = listSharedNotebooks();
      PROCESS_MAP["expungeSharedNotebooks"] = expungeSharedNotebooks();
      PROCESS_MAP["createLinkedNotebook"] = createLinkedNotebook();
      PROCESS_MAP["updateLinkedNotebook"] = updateLinkedNotebook();
      PROCESS_MAP["listLinkedNotebooks"] = listLinkedNotebooks();
      PROCESS_MAP["expungeLinkedNotebook"] = expungeLinkedNotebook();
      PROCESS_MAP["authenticateToSharedNotebook"] = authenticateToSharedNotebook();
      PROCESS_MAP["getSharedNotebookByAuth"] = getSharedNotebookByAuth();
      PROCESS_MAP["emailNote"] = emailNote();
      PROCESS_MAP["shareNote"] = shareNote();
      PROCESS_MAP["stopSharingNote"] = stopSharingNote();
      PROCESS_MAP["authenticateToSharedNote"] = authenticateToSharedNote();
    }

    private var iface_:NoteStore;
    protected const PROCESS_MAP:Dictionary = new Dictionary();

    public function process(iprot:TProtocol, oprot:TProtocol):Boolean
    {
      var msg:TMessage = iprot.readMessageBegin();
      var fn:Function = PROCESS_MAP[msg.name];
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        var x:TApplicationError = new TApplicationError(TApplicationError.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.call(this,msg.seqid, iprot, oprot);
      return true;
    }

    private function getSyncState():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getSyncState_args = new getSyncState_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getSyncState_result = new getSyncState_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getSyncState", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getSyncState");
          oprot.writeMessageBegin(new TMessage("getSyncState", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getSyncState", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getSyncChunk():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getSyncChunk_args = new getSyncChunk_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getSyncChunk_result = new getSyncChunk_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getSyncChunk", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getSyncChunk");
          oprot.writeMessageBegin(new TMessage("getSyncChunk", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getSyncChunk", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getFilteredSyncChunk():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getFilteredSyncChunk_args = new getFilteredSyncChunk_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getFilteredSyncChunk_result = new getFilteredSyncChunk_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getFilteredSyncChunk", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getFilteredSyncChunk");
          oprot.writeMessageBegin(new TMessage("getFilteredSyncChunk", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getFilteredSyncChunk", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getLinkedNotebookSyncState():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getLinkedNotebookSyncState_args = new getLinkedNotebookSyncState_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getLinkedNotebookSyncState_result = new getLinkedNotebookSyncState_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getLinkedNotebookSyncState", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getLinkedNotebookSyncState");
          oprot.writeMessageBegin(new TMessage("getLinkedNotebookSyncState", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getLinkedNotebookSyncState", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getLinkedNotebookSyncChunk():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getLinkedNotebookSyncChunk_args = new getLinkedNotebookSyncChunk_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getLinkedNotebookSyncChunk_result = new getLinkedNotebookSyncChunk_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getLinkedNotebookSyncChunk", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getLinkedNotebookSyncChunk");
          oprot.writeMessageBegin(new TMessage("getLinkedNotebookSyncChunk", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getLinkedNotebookSyncChunk", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function listNotebooks():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:listNotebooks_args = new listNotebooks_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:listNotebooks_result = new listNotebooks_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing listNotebooks", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing listNotebooks");
          oprot.writeMessageBegin(new TMessage("listNotebooks", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listNotebooks", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNotebook_args = new getNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNotebook_result = new getNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNotebook");
          oprot.writeMessageBegin(new TMessage("getNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getDefaultNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getDefaultNotebook_args = new getDefaultNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getDefaultNotebook_result = new getDefaultNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getDefaultNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getDefaultNotebook");
          oprot.writeMessageBegin(new TMessage("getDefaultNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDefaultNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function createNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:createNotebook_args = new createNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:createNotebook_result = new createNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing createNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing createNotebook");
          oprot.writeMessageBegin(new TMessage("createNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function updateNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:updateNotebook_args = new updateNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:updateNotebook_result = new updateNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing updateNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing updateNotebook");
          oprot.writeMessageBegin(new TMessage("updateNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("updateNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeNotebook_args = new expungeNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeNotebook_result = new expungeNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing expungeNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeNotebook");
          oprot.writeMessageBegin(new TMessage("expungeNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function listTags():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:listTags_args = new listTags_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:listTags_result = new listTags_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing listTags", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing listTags");
          oprot.writeMessageBegin(new TMessage("listTags", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listTags", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function listTagsByNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:listTagsByNotebook_args = new listTagsByNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:listTagsByNotebook_result = new listTagsByNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing listTagsByNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing listTagsByNotebook");
          oprot.writeMessageBegin(new TMessage("listTagsByNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listTagsByNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getTag():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getTag_args = new getTag_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getTag_result = new getTag_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getTag", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getTag");
          oprot.writeMessageBegin(new TMessage("getTag", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function createTag():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:createTag_args = new createTag_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:createTag_result = new createTag_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing createTag", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing createTag");
          oprot.writeMessageBegin(new TMessage("createTag", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function updateTag():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:updateTag_args = new updateTag_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:updateTag_result = new updateTag_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing updateTag", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing updateTag");
          oprot.writeMessageBegin(new TMessage("updateTag", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("updateTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function untagAll():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:untagAll_args = new untagAll_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:untagAll_result = new untagAll_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing untagAll", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing untagAll");
          oprot.writeMessageBegin(new TMessage("untagAll", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("untagAll", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeTag():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeTag_args = new expungeTag_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeTag_result = new expungeTag_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing expungeTag", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeTag");
          oprot.writeMessageBegin(new TMessage("expungeTag", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeTag", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function listSearches():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:listSearches_args = new listSearches_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:listSearches_result = new listSearches_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing listSearches", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing listSearches");
          oprot.writeMessageBegin(new TMessage("listSearches", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listSearches", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getSearch():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getSearch_args = new getSearch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getSearch_result = new getSearch_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getSearch", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getSearch");
          oprot.writeMessageBegin(new TMessage("getSearch", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getSearch", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function createSearch():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:createSearch_args = new createSearch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:createSearch_result = new createSearch_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing createSearch", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing createSearch");
          oprot.writeMessageBegin(new TMessage("createSearch", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createSearch", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function updateSearch():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:updateSearch_args = new updateSearch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:updateSearch_result = new updateSearch_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing updateSearch", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing updateSearch");
          oprot.writeMessageBegin(new TMessage("updateSearch", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("updateSearch", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeSearch():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeSearch_args = new expungeSearch_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeSearch_result = new expungeSearch_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing expungeSearch", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeSearch");
          oprot.writeMessageBegin(new TMessage("expungeSearch", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeSearch", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function findNotes():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:findNotes_args = new findNotes_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:findNotes_result = new findNotes_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing findNotes", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing findNotes");
          oprot.writeMessageBegin(new TMessage("findNotes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("findNotes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function findNoteOffset():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:findNoteOffset_args = new findNoteOffset_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:findNoteOffset_result = new findNoteOffset_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing findNoteOffset", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing findNoteOffset");
          oprot.writeMessageBegin(new TMessage("findNoteOffset", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("findNoteOffset", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function findNotesMetadata():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:findNotesMetadata_args = new findNotesMetadata_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:findNotesMetadata_result = new findNotesMetadata_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing findNotesMetadata", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing findNotesMetadata");
          oprot.writeMessageBegin(new TMessage("findNotesMetadata", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("findNotesMetadata", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function findNoteCounts():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:findNoteCounts_args = new findNoteCounts_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:findNoteCounts_result = new findNoteCounts_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing findNoteCounts", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing findNoteCounts");
          oprot.writeMessageBegin(new TMessage("findNoteCounts", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("findNoteCounts", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNote_args = new getNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNote_result = new getNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNote");
          oprot.writeMessageBegin(new TMessage("getNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNoteApplicationData():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNoteApplicationData_args = new getNoteApplicationData_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNoteApplicationData_result = new getNoteApplicationData_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNoteApplicationData", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNoteApplicationData");
          oprot.writeMessageBegin(new TMessage("getNoteApplicationData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNoteApplicationData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNoteApplicationDataEntry():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNoteApplicationDataEntry_args = new getNoteApplicationDataEntry_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNoteApplicationDataEntry_result = new getNoteApplicationDataEntry_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNoteApplicationDataEntry", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNoteApplicationDataEntry");
          oprot.writeMessageBegin(new TMessage("getNoteApplicationDataEntry", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNoteApplicationDataEntry", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function setNoteApplicationDataEntry():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:setNoteApplicationDataEntry_args = new setNoteApplicationDataEntry_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:setNoteApplicationDataEntry_result = new setNoteApplicationDataEntry_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing setNoteApplicationDataEntry", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing setNoteApplicationDataEntry");
          oprot.writeMessageBegin(new TMessage("setNoteApplicationDataEntry", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("setNoteApplicationDataEntry", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function unsetNoteApplicationDataEntry():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:unsetNoteApplicationDataEntry_args = new unsetNoteApplicationDataEntry_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:unsetNoteApplicationDataEntry_result = new unsetNoteApplicationDataEntry_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing unsetNoteApplicationDataEntry", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing unsetNoteApplicationDataEntry");
          oprot.writeMessageBegin(new TMessage("unsetNoteApplicationDataEntry", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("unsetNoteApplicationDataEntry", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNoteContent():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNoteContent_args = new getNoteContent_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNoteContent_result = new getNoteContent_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNoteContent", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNoteContent");
          oprot.writeMessageBegin(new TMessage("getNoteContent", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNoteContent", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNoteSearchText():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNoteSearchText_args = new getNoteSearchText_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNoteSearchText_result = new getNoteSearchText_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNoteSearchText", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNoteSearchText");
          oprot.writeMessageBegin(new TMessage("getNoteSearchText", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNoteSearchText", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceSearchText():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceSearchText_args = new getResourceSearchText_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceSearchText_result = new getResourceSearchText_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceSearchText", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceSearchText");
          oprot.writeMessageBegin(new TMessage("getResourceSearchText", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceSearchText", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNoteTagNames():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNoteTagNames_args = new getNoteTagNames_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNoteTagNames_result = new getNoteTagNames_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNoteTagNames", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNoteTagNames");
          oprot.writeMessageBegin(new TMessage("getNoteTagNames", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNoteTagNames", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function createNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:createNote_args = new createNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:createNote_result = new createNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing createNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing createNote");
          oprot.writeMessageBegin(new TMessage("createNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function updateNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:updateNote_args = new updateNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:updateNote_result = new updateNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing updateNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing updateNote");
          oprot.writeMessageBegin(new TMessage("updateNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("updateNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function deleteNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:deleteNote_args = new deleteNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:deleteNote_result = new deleteNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing deleteNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing deleteNote");
          oprot.writeMessageBegin(new TMessage("deleteNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("deleteNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeNote_args = new expungeNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeNote_result = new expungeNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing expungeNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeNote");
          oprot.writeMessageBegin(new TMessage("expungeNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeNotes():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeNotes_args = new expungeNotes_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeNotes_result = new expungeNotes_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing expungeNotes", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeNotes");
          oprot.writeMessageBegin(new TMessage("expungeNotes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeNotes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeInactiveNotes():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeInactiveNotes_args = new expungeInactiveNotes_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeInactiveNotes_result = new expungeInactiveNotes_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing expungeInactiveNotes", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeInactiveNotes");
          oprot.writeMessageBegin(new TMessage("expungeInactiveNotes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeInactiveNotes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function copyNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:copyNote_args = new copyNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:copyNote_result = new copyNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing copyNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing copyNote");
          oprot.writeMessageBegin(new TMessage("copyNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("copyNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function listNoteVersions():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:listNoteVersions_args = new listNoteVersions_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:listNoteVersions_result = new listNoteVersions_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing listNoteVersions", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing listNoteVersions");
          oprot.writeMessageBegin(new TMessage("listNoteVersions", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listNoteVersions", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNoteVersion():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNoteVersion_args = new getNoteVersion_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNoteVersion_result = new getNoteVersion_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getNoteVersion", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNoteVersion");
          oprot.writeMessageBegin(new TMessage("getNoteVersion", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNoteVersion", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResource():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResource_args = new getResource_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResource_result = new getResource_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResource", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResource");
          oprot.writeMessageBegin(new TMessage("getResource", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResource", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceApplicationData():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceApplicationData_args = new getResourceApplicationData_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceApplicationData_result = new getResourceApplicationData_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceApplicationData", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceApplicationData");
          oprot.writeMessageBegin(new TMessage("getResourceApplicationData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceApplicationData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceApplicationDataEntry():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceApplicationDataEntry_args = new getResourceApplicationDataEntry_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceApplicationDataEntry_result = new getResourceApplicationDataEntry_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceApplicationDataEntry", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceApplicationDataEntry");
          oprot.writeMessageBegin(new TMessage("getResourceApplicationDataEntry", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceApplicationDataEntry", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function setResourceApplicationDataEntry():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:setResourceApplicationDataEntry_args = new setResourceApplicationDataEntry_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:setResourceApplicationDataEntry_result = new setResourceApplicationDataEntry_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing setResourceApplicationDataEntry", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing setResourceApplicationDataEntry");
          oprot.writeMessageBegin(new TMessage("setResourceApplicationDataEntry", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("setResourceApplicationDataEntry", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function unsetResourceApplicationDataEntry():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:unsetResourceApplicationDataEntry_args = new unsetResourceApplicationDataEntry_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:unsetResourceApplicationDataEntry_result = new unsetResourceApplicationDataEntry_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing unsetResourceApplicationDataEntry", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing unsetResourceApplicationDataEntry");
          oprot.writeMessageBegin(new TMessage("unsetResourceApplicationDataEntry", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("unsetResourceApplicationDataEntry", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function updateResource():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:updateResource_args = new updateResource_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:updateResource_result = new updateResource_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing updateResource", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing updateResource");
          oprot.writeMessageBegin(new TMessage("updateResource", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("updateResource", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceData():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceData_args = new getResourceData_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceData_result = new getResourceData_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceData", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceData");
          oprot.writeMessageBegin(new TMessage("getResourceData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceByHash():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceByHash_args = new getResourceByHash_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceByHash_result = new getResourceByHash_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceByHash", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceByHash");
          oprot.writeMessageBegin(new TMessage("getResourceByHash", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceByHash", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceRecognition():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceRecognition_args = new getResourceRecognition_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceRecognition_result = new getResourceRecognition_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceRecognition", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceRecognition");
          oprot.writeMessageBegin(new TMessage("getResourceRecognition", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceRecognition", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceAlternateData():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceAlternateData_args = new getResourceAlternateData_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceAlternateData_result = new getResourceAlternateData_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceAlternateData", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceAlternateData");
          oprot.writeMessageBegin(new TMessage("getResourceAlternateData", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceAlternateData", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getResourceAttributes():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getResourceAttributes_args = new getResourceAttributes_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getResourceAttributes_result = new getResourceAttributes_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getResourceAttributes", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getResourceAttributes");
          oprot.writeMessageBegin(new TMessage("getResourceAttributes", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getResourceAttributes", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getAccountSize():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getAccountSize_args = new getAccountSize_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getAccountSize_result = new getAccountSize_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getAccountSize", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getAccountSize");
          oprot.writeMessageBegin(new TMessage("getAccountSize", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getAccountSize", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getAds():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getAds_args = new getAds_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getAds_result = new getAds_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getAds", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getAds");
          oprot.writeMessageBegin(new TMessage("getAds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getAds", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getRandomAd():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getRandomAd_args = new getRandomAd_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getRandomAd_result = new getRandomAd_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getRandomAd", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getRandomAd");
          oprot.writeMessageBegin(new TMessage("getRandomAd", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getRandomAd", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getPublicNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getPublicNotebook_args = new getPublicNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getPublicNotebook_result = new getPublicNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (th:Error) {
          trace("Internal error processing getPublicNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getPublicNotebook");
          oprot.writeMessageBegin(new TMessage("getPublicNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getPublicNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function createSharedNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:createSharedNotebook_args = new createSharedNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:createSharedNotebook_result = new createSharedNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing createSharedNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing createSharedNotebook");
          oprot.writeMessageBegin(new TMessage("createSharedNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createSharedNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function sendMessageToSharedNotebookMembers():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:sendMessageToSharedNotebookMembers_args = new sendMessageToSharedNotebookMembers_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:sendMessageToSharedNotebookMembers_result = new sendMessageToSharedNotebookMembers_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing sendMessageToSharedNotebookMembers", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing sendMessageToSharedNotebookMembers");
          oprot.writeMessageBegin(new TMessage("sendMessageToSharedNotebookMembers", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("sendMessageToSharedNotebookMembers", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function listSharedNotebooks():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:listSharedNotebooks_args = new listSharedNotebooks_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:listSharedNotebooks_result = new listSharedNotebooks_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing listSharedNotebooks", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing listSharedNotebooks");
          oprot.writeMessageBegin(new TMessage("listSharedNotebooks", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listSharedNotebooks", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeSharedNotebooks():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeSharedNotebooks_args = new expungeSharedNotebooks_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeSharedNotebooks_result = new expungeSharedNotebooks_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing expungeSharedNotebooks", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeSharedNotebooks");
          oprot.writeMessageBegin(new TMessage("expungeSharedNotebooks", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeSharedNotebooks", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function createLinkedNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:createLinkedNotebook_args = new createLinkedNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:createLinkedNotebook_result = new createLinkedNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing createLinkedNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing createLinkedNotebook");
          oprot.writeMessageBegin(new TMessage("createLinkedNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("createLinkedNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function updateLinkedNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:updateLinkedNotebook_args = new updateLinkedNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:updateLinkedNotebook_result = new updateLinkedNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing updateLinkedNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing updateLinkedNotebook");
          oprot.writeMessageBegin(new TMessage("updateLinkedNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("updateLinkedNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function listLinkedNotebooks():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:listLinkedNotebooks_args = new listLinkedNotebooks_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:listLinkedNotebooks_result = new listLinkedNotebooks_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing listLinkedNotebooks", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing listLinkedNotebooks");
          oprot.writeMessageBegin(new TMessage("listLinkedNotebooks", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("listLinkedNotebooks", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function expungeLinkedNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:expungeLinkedNotebook_args = new expungeLinkedNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:expungeLinkedNotebook_result = new expungeLinkedNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing expungeLinkedNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing expungeLinkedNotebook");
          oprot.writeMessageBegin(new TMessage("expungeLinkedNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("expungeLinkedNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function authenticateToSharedNotebook():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:authenticateToSharedNotebook_args = new authenticateToSharedNotebook_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:authenticateToSharedNotebook_result = new authenticateToSharedNotebook_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing authenticateToSharedNotebook", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing authenticateToSharedNotebook");
          oprot.writeMessageBegin(new TMessage("authenticateToSharedNotebook", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("authenticateToSharedNotebook", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getSharedNotebookByAuth():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getSharedNotebookByAuth_args = new getSharedNotebookByAuth_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getSharedNotebookByAuth_result = new getSharedNotebookByAuth_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getSharedNotebookByAuth", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getSharedNotebookByAuth");
          oprot.writeMessageBegin(new TMessage("getSharedNotebookByAuth", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getSharedNotebookByAuth", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function emailNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:emailNote_args = new emailNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:emailNote_result = new emailNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing emailNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing emailNote");
          oprot.writeMessageBegin(new TMessage("emailNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("emailNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function shareNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:shareNote_args = new shareNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:shareNote_result = new shareNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing shareNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing shareNote");
          oprot.writeMessageBegin(new TMessage("shareNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("shareNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function stopSharingNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:stopSharingNote_args = new stopSharingNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:stopSharingNote_result = new stopSharingNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing stopSharingNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing stopSharingNote");
          oprot.writeMessageBegin(new TMessage("stopSharingNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("stopSharingNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function authenticateToSharedNote():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:authenticateToSharedNote_args = new authenticateToSharedNote_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:authenticateToSharedNote_result = new authenticateToSharedNote_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing authenticateToSharedNote", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing authenticateToSharedNote");
          oprot.writeMessageBegin(new TMessage("authenticateToSharedNote", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("authenticateToSharedNote", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

}
import org.apache.thrift.Set;
import org.apache.thrift.type.BigInteger;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

import com.evernote.edam.error.EDAMUserException;
import com.evernote.edam.error.EDAMSystemException;
import com.evernote.edam.notestore.SyncChunkFilter;
import com.evernote.edam.type.LinkedNotebook;
import com.evernote.edam.error.EDAMNotFoundException;
import com.evernote.edam.type.Notebook;
import com.evernote.edam.type.Tag;
import com.evernote.edam.type.SavedSearch;
import com.evernote.edam.notestore.NoteFilter;
import com.evernote.edam.notestore.NotesMetadataResultSpec;
import com.evernote.edam.type.LazyMap;
import com.evernote.edam.type.Note;
import com.evernote.edam.type.Resource;
import com.evernote.edam.type.ResourceAttributes;
import com.evernote.edam.notestore.AdParameters;
import com.evernote.edam.type.Ad;
import com.evernote.edam.type.SharedNotebook;
import com.evernote.edam.userstore.AuthenticationResult;
import com.evernote.edam.notestore.NoteEmailParameters;

import com.evernote.edam.notestore.*;
class getSyncState_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSyncState_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSyncState_args, metaDataMap);
  }

  public function getSyncState_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSyncState_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSyncState_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSyncState_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:SyncState;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SyncState));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSyncState_result, metaDataMap);
  }

  public function getSyncState_result() {
  }

  public function get success():SyncState {
    return this._success;
  }

  public function set success(success:SyncState):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SyncState();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSyncState_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSyncChunk_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSyncChunk_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const AFTER_USN_FIELD_DESC:TField = new TField("afterUSN", TType.I32, 2);
  private static const MAX_ENTRIES_FIELD_DESC:TField = new TField("maxEntries", TType.I32, 3);
  private static const FULL_SYNC_ONLY_FIELD_DESC:TField = new TField("fullSyncOnly", TType.BOOL, 4);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _afterUSN:int;
  public static const AFTERUSN:int = 2;
  private var _maxEntries:int;
  public static const MAXENTRIES:int = 3;
  private var _fullSyncOnly:Boolean;
  public static const FULLSYNCONLY:int = 4;

  private var __isset_afterUSN:Boolean = false;
  private var __isset_maxEntries:Boolean = false;
  private var __isset_fullSyncOnly:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[AFTERUSN] = new FieldMetaData("afterUSN", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[MAXENTRIES] = new FieldMetaData("maxEntries", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[FULLSYNCONLY] = new FieldMetaData("fullSyncOnly", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSyncChunk_args, metaDataMap);
  }

  public function getSyncChunk_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get afterUSN():int {
    return this._afterUSN;
  }

  public function set afterUSN(afterUSN:int):void {
    this._afterUSN = afterUSN;
    this.__isset_afterUSN = true;
  }

  public function unsetAfterUSN():void {
    this.__isset_afterUSN = false;
  }

  // Returns true if field afterUSN is set (has been assigned a value) and false otherwise
  public function isSetAfterUSN():Boolean {
    return this.__isset_afterUSN;
  }

  public function get maxEntries():int {
    return this._maxEntries;
  }

  public function set maxEntries(maxEntries:int):void {
    this._maxEntries = maxEntries;
    this.__isset_maxEntries = true;
  }

  public function unsetMaxEntries():void {
    this.__isset_maxEntries = false;
  }

  // Returns true if field maxEntries is set (has been assigned a value) and false otherwise
  public function isSetMaxEntries():Boolean {
    return this.__isset_maxEntries;
  }

  public function get fullSyncOnly():Boolean {
    return this._fullSyncOnly;
  }

  public function set fullSyncOnly(fullSyncOnly:Boolean):void {
    this._fullSyncOnly = fullSyncOnly;
    this.__isset_fullSyncOnly = true;
  }

  public function unsetFullSyncOnly():void {
    this.__isset_fullSyncOnly = false;
  }

  // Returns true if field fullSyncOnly is set (has been assigned a value) and false otherwise
  public function isSetFullSyncOnly():Boolean {
    return this.__isset_fullSyncOnly;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case AFTERUSN:
      if (value == null) {
        unsetAfterUSN();
      } else {
        this.afterUSN = value;
      }
      break;

    case MAXENTRIES:
      if (value == null) {
        unsetMaxEntries();
      } else {
        this.maxEntries = value;
      }
      break;

    case FULLSYNCONLY:
      if (value == null) {
        unsetFullSyncOnly();
      } else {
        this.fullSyncOnly = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case AFTERUSN:
      return this.afterUSN;
    case MAXENTRIES:
      return this.maxEntries;
    case FULLSYNCONLY:
      return this.fullSyncOnly;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case AFTERUSN:
      return isSetAfterUSN();
    case MAXENTRIES:
      return isSetMaxEntries();
    case FULLSYNCONLY:
      return isSetFullSyncOnly();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case AFTERUSN:
          if (field.type == TType.I32) {
            this.afterUSN = iprot.readI32();
            this.__isset_afterUSN = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAXENTRIES:
          if (field.type == TType.I32) {
            this.maxEntries = iprot.readI32();
            this.__isset_maxEntries = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FULLSYNCONLY:
          if (field.type == TType.BOOL) {
            this.fullSyncOnly = iprot.readBool();
            this.__isset_fullSyncOnly = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(AFTER_USN_FIELD_DESC);
    oprot.writeI32(this.afterUSN);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(MAX_ENTRIES_FIELD_DESC);
    oprot.writeI32(this.maxEntries);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(FULL_SYNC_ONLY_FIELD_DESC);
    oprot.writeBool(this.fullSyncOnly);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSyncChunk_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "afterUSN:";
    ret += this.afterUSN;
    first = false;
    if (!first) ret +=  ", ";
    ret += "maxEntries:";
    ret += this.maxEntries;
    first = false;
    if (!first) ret +=  ", ";
    ret += "fullSyncOnly:";
    ret += this.fullSyncOnly;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSyncChunk_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSyncChunk_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:SyncChunk;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SyncChunk));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSyncChunk_result, metaDataMap);
  }

  public function getSyncChunk_result() {
  }

  public function get success():SyncChunk {
    return this._success;
  }

  public function set success(success:SyncChunk):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SyncChunk();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSyncChunk_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFilteredSyncChunk_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getFilteredSyncChunk_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const AFTER_USN_FIELD_DESC:TField = new TField("afterUSN", TType.I32, 2);
  private static const MAX_ENTRIES_FIELD_DESC:TField = new TField("maxEntries", TType.I32, 3);
  private static const FILTER_FIELD_DESC:TField = new TField("filter", TType.STRUCT, 4);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _afterUSN:int;
  public static const AFTERUSN:int = 2;
  private var _maxEntries:int;
  public static const MAXENTRIES:int = 3;
  private var _filter:SyncChunkFilter;
  public static const FILTER:int = 4;

  private var __isset_afterUSN:Boolean = false;
  private var __isset_maxEntries:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[AFTERUSN] = new FieldMetaData("afterUSN", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[MAXENTRIES] = new FieldMetaData("maxEntries", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[FILTER] = new FieldMetaData("filter", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SyncChunkFilter));
  }
  {
    FieldMetaData.addStructMetaDataMap(getFilteredSyncChunk_args, metaDataMap);
  }

  public function getFilteredSyncChunk_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get afterUSN():int {
    return this._afterUSN;
  }

  public function set afterUSN(afterUSN:int):void {
    this._afterUSN = afterUSN;
    this.__isset_afterUSN = true;
  }

  public function unsetAfterUSN():void {
    this.__isset_afterUSN = false;
  }

  // Returns true if field afterUSN is set (has been assigned a value) and false otherwise
  public function isSetAfterUSN():Boolean {
    return this.__isset_afterUSN;
  }

  public function get maxEntries():int {
    return this._maxEntries;
  }

  public function set maxEntries(maxEntries:int):void {
    this._maxEntries = maxEntries;
    this.__isset_maxEntries = true;
  }

  public function unsetMaxEntries():void {
    this.__isset_maxEntries = false;
  }

  // Returns true if field maxEntries is set (has been assigned a value) and false otherwise
  public function isSetMaxEntries():Boolean {
    return this.__isset_maxEntries;
  }

  public function get filter():SyncChunkFilter {
    return this._filter;
  }

  public function set filter(filter:SyncChunkFilter):void {
    this._filter = filter;
  }

  public function unsetFilter():void {
    this.filter = null;
  }

  // Returns true if field filter is set (has been assigned a value) and false otherwise
  public function isSetFilter():Boolean {
    return this.filter != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case AFTERUSN:
      if (value == null) {
        unsetAfterUSN();
      } else {
        this.afterUSN = value;
      }
      break;

    case MAXENTRIES:
      if (value == null) {
        unsetMaxEntries();
      } else {
        this.maxEntries = value;
      }
      break;

    case FILTER:
      if (value == null) {
        unsetFilter();
      } else {
        this.filter = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case AFTERUSN:
      return this.afterUSN;
    case MAXENTRIES:
      return this.maxEntries;
    case FILTER:
      return this.filter;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case AFTERUSN:
      return isSetAfterUSN();
    case MAXENTRIES:
      return isSetMaxEntries();
    case FILTER:
      return isSetFilter();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case AFTERUSN:
          if (field.type == TType.I32) {
            this.afterUSN = iprot.readI32();
            this.__isset_afterUSN = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAXENTRIES:
          if (field.type == TType.I32) {
            this.maxEntries = iprot.readI32();
            this.__isset_maxEntries = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILTER:
          if (field.type == TType.STRUCT) {
            this.filter = new SyncChunkFilter();
            this.filter.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(AFTER_USN_FIELD_DESC);
    oprot.writeI32(this.afterUSN);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(MAX_ENTRIES_FIELD_DESC);
    oprot.writeI32(this.maxEntries);
    oprot.writeFieldEnd();
    if (this.filter != null) {
      oprot.writeFieldBegin(FILTER_FIELD_DESC);
      this.filter.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getFilteredSyncChunk_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "afterUSN:";
    ret += this.afterUSN;
    first = false;
    if (!first) ret +=  ", ";
    ret += "maxEntries:";
    ret += this.maxEntries;
    first = false;
    if (!first) ret +=  ", ";
    ret += "filter:";
    if (this.filter == null) {
      ret += "null";
    } else {
      ret += this.filter;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getFilteredSyncChunk_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getFilteredSyncChunk_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:SyncChunk;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SyncChunk));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getFilteredSyncChunk_result, metaDataMap);
  }

  public function getFilteredSyncChunk_result() {
  }

  public function get success():SyncChunk {
    return this._success;
  }

  public function set success(success:SyncChunk):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SyncChunk();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getFilteredSyncChunk_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLinkedNotebookSyncState_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getLinkedNotebookSyncState_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const LINKED_NOTEBOOK_FIELD_DESC:TField = new TField("linkedNotebook", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _linkedNotebook:LinkedNotebook;
  public static const LINKEDNOTEBOOK:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[LINKEDNOTEBOOK] = new FieldMetaData("linkedNotebook", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, LinkedNotebook));
  }
  {
    FieldMetaData.addStructMetaDataMap(getLinkedNotebookSyncState_args, metaDataMap);
  }

  public function getLinkedNotebookSyncState_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get linkedNotebook():LinkedNotebook {
    return this._linkedNotebook;
  }

  public function set linkedNotebook(linkedNotebook:LinkedNotebook):void {
    this._linkedNotebook = linkedNotebook;
  }

  public function unsetLinkedNotebook():void {
    this.linkedNotebook = null;
  }

  // Returns true if field linkedNotebook is set (has been assigned a value) and false otherwise
  public function isSetLinkedNotebook():Boolean {
    return this.linkedNotebook != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case LINKEDNOTEBOOK:
      if (value == null) {
        unsetLinkedNotebook();
      } else {
        this.linkedNotebook = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case LINKEDNOTEBOOK:
      return this.linkedNotebook;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case LINKEDNOTEBOOK:
      return isSetLinkedNotebook();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LINKEDNOTEBOOK:
          if (field.type == TType.STRUCT) {
            this.linkedNotebook = new LinkedNotebook();
            this.linkedNotebook.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.linkedNotebook != null) {
      oprot.writeFieldBegin(LINKED_NOTEBOOK_FIELD_DESC);
      this.linkedNotebook.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getLinkedNotebookSyncState_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "linkedNotebook:";
    if (this.linkedNotebook == null) {
      ret += "null";
    } else {
      ret += this.linkedNotebook;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLinkedNotebookSyncState_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getLinkedNotebookSyncState_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:SyncState;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SyncState));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getLinkedNotebookSyncState_result, metaDataMap);
  }

  public function getLinkedNotebookSyncState_result() {
  }

  public function get success():SyncState {
    return this._success;
  }

  public function set success(success:SyncState):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SyncState();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getLinkedNotebookSyncState_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLinkedNotebookSyncChunk_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getLinkedNotebookSyncChunk_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const LINKED_NOTEBOOK_FIELD_DESC:TField = new TField("linkedNotebook", TType.STRUCT, 2);
  private static const AFTER_USN_FIELD_DESC:TField = new TField("afterUSN", TType.I32, 3);
  private static const MAX_ENTRIES_FIELD_DESC:TField = new TField("maxEntries", TType.I32, 4);
  private static const FULL_SYNC_ONLY_FIELD_DESC:TField = new TField("fullSyncOnly", TType.BOOL, 5);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _linkedNotebook:LinkedNotebook;
  public static const LINKEDNOTEBOOK:int = 2;
  private var _afterUSN:int;
  public static const AFTERUSN:int = 3;
  private var _maxEntries:int;
  public static const MAXENTRIES:int = 4;
  private var _fullSyncOnly:Boolean;
  public static const FULLSYNCONLY:int = 5;

  private var __isset_afterUSN:Boolean = false;
  private var __isset_maxEntries:Boolean = false;
  private var __isset_fullSyncOnly:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[LINKEDNOTEBOOK] = new FieldMetaData("linkedNotebook", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, LinkedNotebook));
    metaDataMap[AFTERUSN] = new FieldMetaData("afterUSN", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[MAXENTRIES] = new FieldMetaData("maxEntries", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[FULLSYNCONLY] = new FieldMetaData("fullSyncOnly", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(getLinkedNotebookSyncChunk_args, metaDataMap);
  }

  public function getLinkedNotebookSyncChunk_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get linkedNotebook():LinkedNotebook {
    return this._linkedNotebook;
  }

  public function set linkedNotebook(linkedNotebook:LinkedNotebook):void {
    this._linkedNotebook = linkedNotebook;
  }

  public function unsetLinkedNotebook():void {
    this.linkedNotebook = null;
  }

  // Returns true if field linkedNotebook is set (has been assigned a value) and false otherwise
  public function isSetLinkedNotebook():Boolean {
    return this.linkedNotebook != null;
  }

  public function get afterUSN():int {
    return this._afterUSN;
  }

  public function set afterUSN(afterUSN:int):void {
    this._afterUSN = afterUSN;
    this.__isset_afterUSN = true;
  }

  public function unsetAfterUSN():void {
    this.__isset_afterUSN = false;
  }

  // Returns true if field afterUSN is set (has been assigned a value) and false otherwise
  public function isSetAfterUSN():Boolean {
    return this.__isset_afterUSN;
  }

  public function get maxEntries():int {
    return this._maxEntries;
  }

  public function set maxEntries(maxEntries:int):void {
    this._maxEntries = maxEntries;
    this.__isset_maxEntries = true;
  }

  public function unsetMaxEntries():void {
    this.__isset_maxEntries = false;
  }

  // Returns true if field maxEntries is set (has been assigned a value) and false otherwise
  public function isSetMaxEntries():Boolean {
    return this.__isset_maxEntries;
  }

  public function get fullSyncOnly():Boolean {
    return this._fullSyncOnly;
  }

  public function set fullSyncOnly(fullSyncOnly:Boolean):void {
    this._fullSyncOnly = fullSyncOnly;
    this.__isset_fullSyncOnly = true;
  }

  public function unsetFullSyncOnly():void {
    this.__isset_fullSyncOnly = false;
  }

  // Returns true if field fullSyncOnly is set (has been assigned a value) and false otherwise
  public function isSetFullSyncOnly():Boolean {
    return this.__isset_fullSyncOnly;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case LINKEDNOTEBOOK:
      if (value == null) {
        unsetLinkedNotebook();
      } else {
        this.linkedNotebook = value;
      }
      break;

    case AFTERUSN:
      if (value == null) {
        unsetAfterUSN();
      } else {
        this.afterUSN = value;
      }
      break;

    case MAXENTRIES:
      if (value == null) {
        unsetMaxEntries();
      } else {
        this.maxEntries = value;
      }
      break;

    case FULLSYNCONLY:
      if (value == null) {
        unsetFullSyncOnly();
      } else {
        this.fullSyncOnly = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case LINKEDNOTEBOOK:
      return this.linkedNotebook;
    case AFTERUSN:
      return this.afterUSN;
    case MAXENTRIES:
      return this.maxEntries;
    case FULLSYNCONLY:
      return this.fullSyncOnly;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case LINKEDNOTEBOOK:
      return isSetLinkedNotebook();
    case AFTERUSN:
      return isSetAfterUSN();
    case MAXENTRIES:
      return isSetMaxEntries();
    case FULLSYNCONLY:
      return isSetFullSyncOnly();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LINKEDNOTEBOOK:
          if (field.type == TType.STRUCT) {
            this.linkedNotebook = new LinkedNotebook();
            this.linkedNotebook.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case AFTERUSN:
          if (field.type == TType.I32) {
            this.afterUSN = iprot.readI32();
            this.__isset_afterUSN = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAXENTRIES:
          if (field.type == TType.I32) {
            this.maxEntries = iprot.readI32();
            this.__isset_maxEntries = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FULLSYNCONLY:
          if (field.type == TType.BOOL) {
            this.fullSyncOnly = iprot.readBool();
            this.__isset_fullSyncOnly = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.linkedNotebook != null) {
      oprot.writeFieldBegin(LINKED_NOTEBOOK_FIELD_DESC);
      this.linkedNotebook.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(AFTER_USN_FIELD_DESC);
    oprot.writeI32(this.afterUSN);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(MAX_ENTRIES_FIELD_DESC);
    oprot.writeI32(this.maxEntries);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(FULL_SYNC_ONLY_FIELD_DESC);
    oprot.writeBool(this.fullSyncOnly);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getLinkedNotebookSyncChunk_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "linkedNotebook:";
    if (this.linkedNotebook == null) {
      ret += "null";
    } else {
      ret += this.linkedNotebook;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "afterUSN:";
    ret += this.afterUSN;
    first = false;
    if (!first) ret +=  ", ";
    ret += "maxEntries:";
    ret += this.maxEntries;
    first = false;
    if (!first) ret +=  ", ";
    ret += "fullSyncOnly:";
    ret += this.fullSyncOnly;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getLinkedNotebookSyncChunk_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getLinkedNotebookSyncChunk_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:SyncChunk;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SyncChunk));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getLinkedNotebookSyncChunk_result, metaDataMap);
  }

  public function getLinkedNotebookSyncChunk_result() {
  }

  public function get success():SyncChunk {
    return this._success;
  }

  public function set success(success:SyncChunk):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SyncChunk();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getLinkedNotebookSyncChunk_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listNotebooks_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listNotebooks_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(listNotebooks_args, metaDataMap);
  }

  public function listNotebooks_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listNotebooks_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listNotebooks_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listNotebooks_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Notebook)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(listNotebooks_result, metaDataMap);
  }

  public function listNotebooks_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list745:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i746:int = 0; _i746 < _list745.size; ++_i746)
              {
                var _elem747:Notebook;
                _elem747 = new Notebook();
                _elem747.read(iprot);
                this.success.push(_elem747);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem748:* in this.success)        {
          elem748.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listNotebooks_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNotebook_args, metaDataMap);
  }

  public function getNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Notebook;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Notebook));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNotebook_result, metaDataMap);
  }

  public function getNotebook_result() {
  }

  public function get success():Notebook {
    return this._success;
  }

  public function set success(success:Notebook):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Notebook();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDefaultNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getDefaultNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getDefaultNotebook_args, metaDataMap);
  }

  public function getDefaultNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getDefaultNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getDefaultNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getDefaultNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:Notebook;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Notebook));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getDefaultNotebook_result, metaDataMap);
  }

  public function getDefaultNotebook_result() {
  }

  public function get success():Notebook {
    return this._success;
  }

  public function set success(success:Notebook):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Notebook();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getDefaultNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTEBOOK_FIELD_DESC:TField = new TField("notebook", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _notebook:Notebook;
  public static const NOTEBOOK:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEBOOK] = new FieldMetaData("notebook", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Notebook));
  }
  {
    FieldMetaData.addStructMetaDataMap(createNotebook_args, metaDataMap);
  }

  public function createNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get notebook():Notebook {
    return this._notebook;
  }

  public function set notebook(notebook:Notebook):void {
    this._notebook = notebook;
  }

  public function unsetNotebook():void {
    this.notebook = null;
  }

  // Returns true if field notebook is set (has been assigned a value) and false otherwise
  public function isSetNotebook():Boolean {
    return this.notebook != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEBOOK:
      if (value == null) {
        unsetNotebook();
      } else {
        this.notebook = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEBOOK:
      return this.notebook;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEBOOK:
      return isSetNotebook();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEBOOK:
          if (field.type == TType.STRUCT) {
            this.notebook = new Notebook();
            this.notebook.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.notebook != null) {
      oprot.writeFieldBegin(NOTEBOOK_FIELD_DESC);
      this.notebook.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notebook:";
    if (this.notebook == null) {
      ret += "null";
    } else {
      ret += this.notebook;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:Notebook;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Notebook));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(createNotebook_result, metaDataMap);
  }

  public function createNotebook_result() {
  }

  public function get success():Notebook {
    return this._success;
  }

  public function set success(success:Notebook):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Notebook();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTEBOOK_FIELD_DESC:TField = new TField("notebook", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _notebook:Notebook;
  public static const NOTEBOOK:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEBOOK] = new FieldMetaData("notebook", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Notebook));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateNotebook_args, metaDataMap);
  }

  public function updateNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get notebook():Notebook {
    return this._notebook;
  }

  public function set notebook(notebook:Notebook):void {
    this._notebook = notebook;
  }

  public function unsetNotebook():void {
    this.notebook = null;
  }

  // Returns true if field notebook is set (has been assigned a value) and false otherwise
  public function isSetNotebook():Boolean {
    return this.notebook != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEBOOK:
      if (value == null) {
        unsetNotebook();
      } else {
        this.notebook = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEBOOK:
      return this.notebook;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEBOOK:
      return isSetNotebook();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEBOOK:
          if (field.type == TType.STRUCT) {
            this.notebook = new Notebook();
            this.notebook.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.notebook != null) {
      oprot.writeFieldBegin(NOTEBOOK_FIELD_DESC);
      this.notebook.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notebook:";
    if (this.notebook == null) {
      ret += "null";
    } else {
      ret += this.notebook;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateNotebook_result, metaDataMap);
  }

  public function updateNotebook_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeNotebook_args, metaDataMap);
  }

  public function expungeNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeNotebook_result, metaDataMap);
  }

  public function expungeNotebook_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listTags_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listTags_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(listTags_args, metaDataMap);
  }

  public function listTags_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listTags_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listTags_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listTags_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Tag)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(listTags_result, metaDataMap);
  }

  public function listTags_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list780:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i781:int = 0; _i781 < _list780.size; ++_i781)
              {
                var _elem782:Tag;
                _elem782 = new Tag();
                _elem782.read(iprot);
                this.success.push(_elem782);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem783:* in this.success)        {
          elem783.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listTags_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listTagsByNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listTagsByNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTEBOOK_GUID_FIELD_DESC:TField = new TField("notebookGuid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _notebookGuid:String;
  public static const NOTEBOOKGUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEBOOKGUID] = new FieldMetaData("notebookGuid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(listTagsByNotebook_args, metaDataMap);
  }

  public function listTagsByNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get notebookGuid():String {
    return this._notebookGuid;
  }

  public function set notebookGuid(notebookGuid:String):void {
    this._notebookGuid = notebookGuid;
  }

  public function unsetNotebookGuid():void {
    this.notebookGuid = null;
  }

  // Returns true if field notebookGuid is set (has been assigned a value) and false otherwise
  public function isSetNotebookGuid():Boolean {
    return this.notebookGuid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEBOOKGUID:
      if (value == null) {
        unsetNotebookGuid();
      } else {
        this.notebookGuid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEBOOKGUID:
      return this.notebookGuid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEBOOKGUID:
      return isSetNotebookGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEBOOKGUID:
          if (field.type == TType.STRING) {
            this.notebookGuid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.notebookGuid != null) {
      oprot.writeFieldBegin(NOTEBOOK_GUID_FIELD_DESC);
      oprot.writeString(this.notebookGuid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listTagsByNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notebookGuid:";
    if (this.notebookGuid == null) {
      ret += "null";
    } else {
      ret += this.notebookGuid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listTagsByNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listTagsByNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Tag)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(listTagsByNotebook_result, metaDataMap);
  }

  public function listTagsByNotebook_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list790:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i791:int = 0; _i791 < _list790.size; ++_i791)
              {
                var _elem792:Tag;
                _elem792 = new Tag();
                _elem792.read(iprot);
                this.success.push(_elem792);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem793:* in this.success)        {
          elem793.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listTagsByNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getTag_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getTag_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getTag_args, metaDataMap);
  }

  public function getTag_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getTag_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getTag_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getTag_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Tag;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Tag));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getTag_result, metaDataMap);
  }

  public function getTag_result() {
  }

  public function get success():Tag {
    return this._success;
  }

  public function set success(success:Tag):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Tag();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getTag_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createTag_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createTag_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const TAG_FIELD_DESC:TField = new TField("tag", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _tag:Tag;
  public static const TAG:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[TAG] = new FieldMetaData("tag", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Tag));
  }
  {
    FieldMetaData.addStructMetaDataMap(createTag_args, metaDataMap);
  }

  public function createTag_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get tag():Tag {
    return this._tag;
  }

  public function set tag(tag:Tag):void {
    this._tag = tag;
  }

  public function unsetTag():void {
    this.tag = null;
  }

  // Returns true if field tag is set (has been assigned a value) and false otherwise
  public function isSetTag():Boolean {
    return this.tag != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case TAG:
      if (value == null) {
        unsetTag();
      } else {
        this.tag = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case TAG:
      return this.tag;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case TAG:
      return isSetTag();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TAG:
          if (field.type == TType.STRUCT) {
            this.tag = new Tag();
            this.tag.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.tag != null) {
      oprot.writeFieldBegin(TAG_FIELD_DESC);
      this.tag.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createTag_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "tag:";
    if (this.tag == null) {
      ret += "null";
    } else {
      ret += this.tag;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createTag_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createTag_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Tag;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Tag));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(createTag_result, metaDataMap);
  }

  public function createTag_result() {
  }

  public function get success():Tag {
    return this._success;
  }

  public function set success(success:Tag):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Tag();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createTag_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateTag_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateTag_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const TAG_FIELD_DESC:TField = new TField("tag", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _tag:Tag;
  public static const TAG:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[TAG] = new FieldMetaData("tag", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Tag));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateTag_args, metaDataMap);
  }

  public function updateTag_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get tag():Tag {
    return this._tag;
  }

  public function set tag(tag:Tag):void {
    this._tag = tag;
  }

  public function unsetTag():void {
    this.tag = null;
  }

  // Returns true if field tag is set (has been assigned a value) and false otherwise
  public function isSetTag():Boolean {
    return this.tag != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case TAG:
      if (value == null) {
        unsetTag();
      } else {
        this.tag = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case TAG:
      return this.tag;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case TAG:
      return isSetTag();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TAG:
          if (field.type == TType.STRUCT) {
            this.tag = new Tag();
            this.tag.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.tag != null) {
      oprot.writeFieldBegin(TAG_FIELD_DESC);
      this.tag.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateTag_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "tag:";
    if (this.tag == null) {
      ret += "null";
    } else {
      ret += this.tag;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateTag_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateTag_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateTag_result, metaDataMap);
  }

  public function updateTag_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateTag_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class untagAll_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("untagAll_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(untagAll_args, metaDataMap);
  }

  public function untagAll_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("untagAll_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class untagAll_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("untagAll_result");
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(untagAll_result, metaDataMap);
  }

  public function untagAll_result() {
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("untagAll_result(");
    var first:Boolean = true;

    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeTag_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeTag_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeTag_args, metaDataMap);
  }

  public function expungeTag_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeTag_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeTag_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeTag_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeTag_result, metaDataMap);
  }

  public function expungeTag_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeTag_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listSearches_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listSearches_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(listSearches_args, metaDataMap);
  }

  public function listSearches_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listSearches_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listSearches_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listSearches_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, SavedSearch)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(listSearches_result, metaDataMap);
  }

  public function listSearches_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list827:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i828:int = 0; _i828 < _list827.size; ++_i828)
              {
                var _elem829:SavedSearch;
                _elem829 = new SavedSearch();
                _elem829.read(iprot);
                this.success.push(_elem829);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem830:* in this.success)        {
          elem830.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listSearches_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSearch_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSearch_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSearch_args, metaDataMap);
  }

  public function getSearch_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSearch_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSearch_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSearch_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:SavedSearch;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SavedSearch));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSearch_result, metaDataMap);
  }

  public function getSearch_result() {
  }

  public function get success():SavedSearch {
    return this._success;
  }

  public function set success(success:SavedSearch):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SavedSearch();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSearch_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createSearch_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createSearch_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const SEARCH_FIELD_DESC:TField = new TField("search", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _search:SavedSearch;
  public static const SEARCH:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SEARCH] = new FieldMetaData("search", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SavedSearch));
  }
  {
    FieldMetaData.addStructMetaDataMap(createSearch_args, metaDataMap);
  }

  public function createSearch_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get search():SavedSearch {
    return this._search;
  }

  public function set search(search:SavedSearch):void {
    this._search = search;
  }

  public function unsetSearch():void {
    this.search = null;
  }

  // Returns true if field search is set (has been assigned a value) and false otherwise
  public function isSetSearch():Boolean {
    return this.search != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case SEARCH:
      if (value == null) {
        unsetSearch();
      } else {
        this.search = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case SEARCH:
      return this.search;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case SEARCH:
      return isSetSearch();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SEARCH:
          if (field.type == TType.STRUCT) {
            this.search = new SavedSearch();
            this.search.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.search != null) {
      oprot.writeFieldBegin(SEARCH_FIELD_DESC);
      this.search.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createSearch_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "search:";
    if (this.search == null) {
      ret += "null";
    } else {
      ret += this.search;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createSearch_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createSearch_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:SavedSearch;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SavedSearch));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(createSearch_result, metaDataMap);
  }

  public function createSearch_result() {
  }

  public function get success():SavedSearch {
    return this._success;
  }

  public function set success(success:SavedSearch):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SavedSearch();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createSearch_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSearch_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateSearch_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const SEARCH_FIELD_DESC:TField = new TField("search", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _search:SavedSearch;
  public static const SEARCH:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SEARCH] = new FieldMetaData("search", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SavedSearch));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateSearch_args, metaDataMap);
  }

  public function updateSearch_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get search():SavedSearch {
    return this._search;
  }

  public function set search(search:SavedSearch):void {
    this._search = search;
  }

  public function unsetSearch():void {
    this.search = null;
  }

  // Returns true if field search is set (has been assigned a value) and false otherwise
  public function isSetSearch():Boolean {
    return this.search != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case SEARCH:
      if (value == null) {
        unsetSearch();
      } else {
        this.search = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case SEARCH:
      return this.search;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case SEARCH:
      return isSetSearch();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SEARCH:
          if (field.type == TType.STRUCT) {
            this.search = new SavedSearch();
            this.search.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.search != null) {
      oprot.writeFieldBegin(SEARCH_FIELD_DESC);
      this.search.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateSearch_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "search:";
    if (this.search == null) {
      ret += "null";
    } else {
      ret += this.search;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateSearch_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateSearch_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateSearch_result, metaDataMap);
  }

  public function updateSearch_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateSearch_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeSearch_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeSearch_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeSearch_args, metaDataMap);
  }

  public function expungeSearch_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeSearch_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeSearch_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeSearch_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeSearch_result, metaDataMap);
  }

  public function expungeSearch_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeSearch_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNotes_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNotes_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const FILTER_FIELD_DESC:TField = new TField("filter", TType.STRUCT, 2);
  private static const OFFSET_FIELD_DESC:TField = new TField("offset", TType.I32, 3);
  private static const MAX_NOTES_FIELD_DESC:TField = new TField("maxNotes", TType.I32, 4);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _filter:NoteFilter;
  public static const FILTER:int = 2;
  private var _offset:int;
  public static const OFFSET:int = 3;
  private var _maxNotes:int;
  public static const MAXNOTES:int = 4;

  private var __isset_offset:Boolean = false;
  private var __isset_maxNotes:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[FILTER] = new FieldMetaData("filter", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NoteFilter));
    metaDataMap[OFFSET] = new FieldMetaData("offset", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[MAXNOTES] = new FieldMetaData("maxNotes", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNotes_args, metaDataMap);
  }

  public function findNotes_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get filter():NoteFilter {
    return this._filter;
  }

  public function set filter(filter:NoteFilter):void {
    this._filter = filter;
  }

  public function unsetFilter():void {
    this.filter = null;
  }

  // Returns true if field filter is set (has been assigned a value) and false otherwise
  public function isSetFilter():Boolean {
    return this.filter != null;
  }

  public function get offset():int {
    return this._offset;
  }

  public function set offset(offset:int):void {
    this._offset = offset;
    this.__isset_offset = true;
  }

  public function unsetOffset():void {
    this.__isset_offset = false;
  }

  // Returns true if field offset is set (has been assigned a value) and false otherwise
  public function isSetOffset():Boolean {
    return this.__isset_offset;
  }

  public function get maxNotes():int {
    return this._maxNotes;
  }

  public function set maxNotes(maxNotes:int):void {
    this._maxNotes = maxNotes;
    this.__isset_maxNotes = true;
  }

  public function unsetMaxNotes():void {
    this.__isset_maxNotes = false;
  }

  // Returns true if field maxNotes is set (has been assigned a value) and false otherwise
  public function isSetMaxNotes():Boolean {
    return this.__isset_maxNotes;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case FILTER:
      if (value == null) {
        unsetFilter();
      } else {
        this.filter = value;
      }
      break;

    case OFFSET:
      if (value == null) {
        unsetOffset();
      } else {
        this.offset = value;
      }
      break;

    case MAXNOTES:
      if (value == null) {
        unsetMaxNotes();
      } else {
        this.maxNotes = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case FILTER:
      return this.filter;
    case OFFSET:
      return this.offset;
    case MAXNOTES:
      return this.maxNotes;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case FILTER:
      return isSetFilter();
    case OFFSET:
      return isSetOffset();
    case MAXNOTES:
      return isSetMaxNotes();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILTER:
          if (field.type == TType.STRUCT) {
            this.filter = new NoteFilter();
            this.filter.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I32) {
            this.offset = iprot.readI32();
            this.__isset_offset = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAXNOTES:
          if (field.type == TType.I32) {
            this.maxNotes = iprot.readI32();
            this.__isset_maxNotes = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.filter != null) {
      oprot.writeFieldBegin(FILTER_FIELD_DESC);
      this.filter.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(OFFSET_FIELD_DESC);
    oprot.writeI32(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(MAX_NOTES_FIELD_DESC);
    oprot.writeI32(this.maxNotes);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNotes_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "filter:";
    if (this.filter == null) {
      ret += "null";
    } else {
      ret += this.filter;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "offset:";
    ret += this.offset;
    first = false;
    if (!first) ret +=  ", ";
    ret += "maxNotes:";
    ret += this.maxNotes;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNotes_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNotes_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:NoteList;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NoteList));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNotes_result, metaDataMap);
  }

  public function findNotes_result() {
  }

  public function get success():NoteList {
    return this._success;
  }

  public function set success(success:NoteList):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new NoteList();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNotes_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNoteOffset_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNoteOffset_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const FILTER_FIELD_DESC:TField = new TField("filter", TType.STRUCT, 2);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 3);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _filter:NoteFilter;
  public static const FILTER:int = 2;
  private var _guid:String;
  public static const GUID:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[FILTER] = new FieldMetaData("filter", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NoteFilter));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNoteOffset_args, metaDataMap);
  }

  public function findNoteOffset_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get filter():NoteFilter {
    return this._filter;
  }

  public function set filter(filter:NoteFilter):void {
    this._filter = filter;
  }

  public function unsetFilter():void {
    this.filter = null;
  }

  // Returns true if field filter is set (has been assigned a value) and false otherwise
  public function isSetFilter():Boolean {
    return this.filter != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case FILTER:
      if (value == null) {
        unsetFilter();
      } else {
        this.filter = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case FILTER:
      return this.filter;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case FILTER:
      return isSetFilter();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILTER:
          if (field.type == TType.STRUCT) {
            this.filter = new NoteFilter();
            this.filter.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.filter != null) {
      oprot.writeFieldBegin(FILTER_FIELD_DESC);
      this.filter.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNoteOffset_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "filter:";
    if (this.filter == null) {
      ret += "null";
    } else {
      ret += this.filter;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNoteOffset_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNoteOffset_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNoteOffset_result, metaDataMap);
  }

  public function findNoteOffset_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNoteOffset_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNotesMetadata_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNotesMetadata_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const FILTER_FIELD_DESC:TField = new TField("filter", TType.STRUCT, 2);
  private static const OFFSET_FIELD_DESC:TField = new TField("offset", TType.I32, 3);
  private static const MAX_NOTES_FIELD_DESC:TField = new TField("maxNotes", TType.I32, 4);
  private static const RESULT_SPEC_FIELD_DESC:TField = new TField("resultSpec", TType.STRUCT, 5);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _filter:NoteFilter;
  public static const FILTER:int = 2;
  private var _offset:int;
  public static const OFFSET:int = 3;
  private var _maxNotes:int;
  public static const MAXNOTES:int = 4;
  private var _resultSpec:NotesMetadataResultSpec;
  public static const RESULTSPEC:int = 5;

  private var __isset_offset:Boolean = false;
  private var __isset_maxNotes:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[FILTER] = new FieldMetaData("filter", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NoteFilter));
    metaDataMap[OFFSET] = new FieldMetaData("offset", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[MAXNOTES] = new FieldMetaData("maxNotes", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[RESULTSPEC] = new FieldMetaData("resultSpec", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NotesMetadataResultSpec));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNotesMetadata_args, metaDataMap);
  }

  public function findNotesMetadata_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get filter():NoteFilter {
    return this._filter;
  }

  public function set filter(filter:NoteFilter):void {
    this._filter = filter;
  }

  public function unsetFilter():void {
    this.filter = null;
  }

  // Returns true if field filter is set (has been assigned a value) and false otherwise
  public function isSetFilter():Boolean {
    return this.filter != null;
  }

  public function get offset():int {
    return this._offset;
  }

  public function set offset(offset:int):void {
    this._offset = offset;
    this.__isset_offset = true;
  }

  public function unsetOffset():void {
    this.__isset_offset = false;
  }

  // Returns true if field offset is set (has been assigned a value) and false otherwise
  public function isSetOffset():Boolean {
    return this.__isset_offset;
  }

  public function get maxNotes():int {
    return this._maxNotes;
  }

  public function set maxNotes(maxNotes:int):void {
    this._maxNotes = maxNotes;
    this.__isset_maxNotes = true;
  }

  public function unsetMaxNotes():void {
    this.__isset_maxNotes = false;
  }

  // Returns true if field maxNotes is set (has been assigned a value) and false otherwise
  public function isSetMaxNotes():Boolean {
    return this.__isset_maxNotes;
  }

  public function get resultSpec():NotesMetadataResultSpec {
    return this._resultSpec;
  }

  public function set resultSpec(resultSpec:NotesMetadataResultSpec):void {
    this._resultSpec = resultSpec;
  }

  public function unsetResultSpec():void {
    this.resultSpec = null;
  }

  // Returns true if field resultSpec is set (has been assigned a value) and false otherwise
  public function isSetResultSpec():Boolean {
    return this.resultSpec != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case FILTER:
      if (value == null) {
        unsetFilter();
      } else {
        this.filter = value;
      }
      break;

    case OFFSET:
      if (value == null) {
        unsetOffset();
      } else {
        this.offset = value;
      }
      break;

    case MAXNOTES:
      if (value == null) {
        unsetMaxNotes();
      } else {
        this.maxNotes = value;
      }
      break;

    case RESULTSPEC:
      if (value == null) {
        unsetResultSpec();
      } else {
        this.resultSpec = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case FILTER:
      return this.filter;
    case OFFSET:
      return this.offset;
    case MAXNOTES:
      return this.maxNotes;
    case RESULTSPEC:
      return this.resultSpec;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case FILTER:
      return isSetFilter();
    case OFFSET:
      return isSetOffset();
    case MAXNOTES:
      return isSetMaxNotes();
    case RESULTSPEC:
      return isSetResultSpec();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILTER:
          if (field.type == TType.STRUCT) {
            this.filter = new NoteFilter();
            this.filter.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case OFFSET:
          if (field.type == TType.I32) {
            this.offset = iprot.readI32();
            this.__isset_offset = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MAXNOTES:
          if (field.type == TType.I32) {
            this.maxNotes = iprot.readI32();
            this.__isset_maxNotes = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RESULTSPEC:
          if (field.type == TType.STRUCT) {
            this.resultSpec = new NotesMetadataResultSpec();
            this.resultSpec.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.filter != null) {
      oprot.writeFieldBegin(FILTER_FIELD_DESC);
      this.filter.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(OFFSET_FIELD_DESC);
    oprot.writeI32(this.offset);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(MAX_NOTES_FIELD_DESC);
    oprot.writeI32(this.maxNotes);
    oprot.writeFieldEnd();
    if (this.resultSpec != null) {
      oprot.writeFieldBegin(RESULT_SPEC_FIELD_DESC);
      this.resultSpec.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNotesMetadata_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "filter:";
    if (this.filter == null) {
      ret += "null";
    } else {
      ret += this.filter;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "offset:";
    ret += this.offset;
    first = false;
    if (!first) ret +=  ", ";
    ret += "maxNotes:";
    ret += this.maxNotes;
    first = false;
    if (!first) ret +=  ", ";
    ret += "resultSpec:";
    if (this.resultSpec == null) {
      ret += "null";
    } else {
      ret += this.resultSpec;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNotesMetadata_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNotesMetadata_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:NotesMetadataList;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NotesMetadataList));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNotesMetadata_result, metaDataMap);
  }

  public function findNotesMetadata_result() {
  }

  public function get success():NotesMetadataList {
    return this._success;
  }

  public function set success(success:NotesMetadataList):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new NotesMetadataList();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNotesMetadata_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNoteCounts_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNoteCounts_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const FILTER_FIELD_DESC:TField = new TField("filter", TType.STRUCT, 2);
  private static const WITH_TRASH_FIELD_DESC:TField = new TField("withTrash", TType.BOOL, 3);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _filter:NoteFilter;
  public static const FILTER:int = 2;
  private var _withTrash:Boolean;
  public static const WITHTRASH:int = 3;

  private var __isset_withTrash:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[FILTER] = new FieldMetaData("filter", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NoteFilter));
    metaDataMap[WITHTRASH] = new FieldMetaData("withTrash", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNoteCounts_args, metaDataMap);
  }

  public function findNoteCounts_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get filter():NoteFilter {
    return this._filter;
  }

  public function set filter(filter:NoteFilter):void {
    this._filter = filter;
  }

  public function unsetFilter():void {
    this.filter = null;
  }

  // Returns true if field filter is set (has been assigned a value) and false otherwise
  public function isSetFilter():Boolean {
    return this.filter != null;
  }

  public function get withTrash():Boolean {
    return this._withTrash;
  }

  public function set withTrash(withTrash:Boolean):void {
    this._withTrash = withTrash;
    this.__isset_withTrash = true;
  }

  public function unsetWithTrash():void {
    this.__isset_withTrash = false;
  }

  // Returns true if field withTrash is set (has been assigned a value) and false otherwise
  public function isSetWithTrash():Boolean {
    return this.__isset_withTrash;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case FILTER:
      if (value == null) {
        unsetFilter();
      } else {
        this.filter = value;
      }
      break;

    case WITHTRASH:
      if (value == null) {
        unsetWithTrash();
      } else {
        this.withTrash = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case FILTER:
      return this.filter;
    case WITHTRASH:
      return this.withTrash;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case FILTER:
      return isSetFilter();
    case WITHTRASH:
      return isSetWithTrash();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FILTER:
          if (field.type == TType.STRUCT) {
            this.filter = new NoteFilter();
            this.filter.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHTRASH:
          if (field.type == TType.BOOL) {
            this.withTrash = iprot.readBool();
            this.__isset_withTrash = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.filter != null) {
      oprot.writeFieldBegin(FILTER_FIELD_DESC);
      this.filter.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(WITH_TRASH_FIELD_DESC);
    oprot.writeBool(this.withTrash);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNoteCounts_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "filter:";
    if (this.filter == null) {
      ret += "null";
    } else {
      ret += this.filter;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "withTrash:";
    ret += this.withTrash;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class findNoteCounts_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("findNoteCounts_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:NoteCollectionCounts;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NoteCollectionCounts));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(findNoteCounts_result, metaDataMap);
  }

  public function findNoteCounts_result() {
  }

  public function get success():NoteCollectionCounts {
    return this._success;
  }

  public function set success(success:NoteCollectionCounts):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new NoteCollectionCounts();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("findNoteCounts_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const WITH_CONTENT_FIELD_DESC:TField = new TField("withContent", TType.BOOL, 3);
  private static const WITH_RESOURCES_DATA_FIELD_DESC:TField = new TField("withResourcesData", TType.BOOL, 4);
  private static const WITH_RESOURCES_RECOGNITION_FIELD_DESC:TField = new TField("withResourcesRecognition", TType.BOOL, 5);
  private static const WITH_RESOURCES_ALTERNATE_DATA_FIELD_DESC:TField = new TField("withResourcesAlternateData", TType.BOOL, 6);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _withContent:Boolean;
  public static const WITHCONTENT:int = 3;
  private var _withResourcesData:Boolean;
  public static const WITHRESOURCESDATA:int = 4;
  private var _withResourcesRecognition:Boolean;
  public static const WITHRESOURCESRECOGNITION:int = 5;
  private var _withResourcesAlternateData:Boolean;
  public static const WITHRESOURCESALTERNATEDATA:int = 6;

  private var __isset_withContent:Boolean = false;
  private var __isset_withResourcesData:Boolean = false;
  private var __isset_withResourcesRecognition:Boolean = false;
  private var __isset_withResourcesAlternateData:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[WITHCONTENT] = new FieldMetaData("withContent", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHRESOURCESDATA] = new FieldMetaData("withResourcesData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHRESOURCESRECOGNITION] = new FieldMetaData("withResourcesRecognition", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHRESOURCESALTERNATEDATA] = new FieldMetaData("withResourcesAlternateData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNote_args, metaDataMap);
  }

  public function getNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get withContent():Boolean {
    return this._withContent;
  }

  public function set withContent(withContent:Boolean):void {
    this._withContent = withContent;
    this.__isset_withContent = true;
  }

  public function unsetWithContent():void {
    this.__isset_withContent = false;
  }

  // Returns true if field withContent is set (has been assigned a value) and false otherwise
  public function isSetWithContent():Boolean {
    return this.__isset_withContent;
  }

  public function get withResourcesData():Boolean {
    return this._withResourcesData;
  }

  public function set withResourcesData(withResourcesData:Boolean):void {
    this._withResourcesData = withResourcesData;
    this.__isset_withResourcesData = true;
  }

  public function unsetWithResourcesData():void {
    this.__isset_withResourcesData = false;
  }

  // Returns true if field withResourcesData is set (has been assigned a value) and false otherwise
  public function isSetWithResourcesData():Boolean {
    return this.__isset_withResourcesData;
  }

  public function get withResourcesRecognition():Boolean {
    return this._withResourcesRecognition;
  }

  public function set withResourcesRecognition(withResourcesRecognition:Boolean):void {
    this._withResourcesRecognition = withResourcesRecognition;
    this.__isset_withResourcesRecognition = true;
  }

  public function unsetWithResourcesRecognition():void {
    this.__isset_withResourcesRecognition = false;
  }

  // Returns true if field withResourcesRecognition is set (has been assigned a value) and false otherwise
  public function isSetWithResourcesRecognition():Boolean {
    return this.__isset_withResourcesRecognition;
  }

  public function get withResourcesAlternateData():Boolean {
    return this._withResourcesAlternateData;
  }

  public function set withResourcesAlternateData(withResourcesAlternateData:Boolean):void {
    this._withResourcesAlternateData = withResourcesAlternateData;
    this.__isset_withResourcesAlternateData = true;
  }

  public function unsetWithResourcesAlternateData():void {
    this.__isset_withResourcesAlternateData = false;
  }

  // Returns true if field withResourcesAlternateData is set (has been assigned a value) and false otherwise
  public function isSetWithResourcesAlternateData():Boolean {
    return this.__isset_withResourcesAlternateData;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case WITHCONTENT:
      if (value == null) {
        unsetWithContent();
      } else {
        this.withContent = value;
      }
      break;

    case WITHRESOURCESDATA:
      if (value == null) {
        unsetWithResourcesData();
      } else {
        this.withResourcesData = value;
      }
      break;

    case WITHRESOURCESRECOGNITION:
      if (value == null) {
        unsetWithResourcesRecognition();
      } else {
        this.withResourcesRecognition = value;
      }
      break;

    case WITHRESOURCESALTERNATEDATA:
      if (value == null) {
        unsetWithResourcesAlternateData();
      } else {
        this.withResourcesAlternateData = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case WITHCONTENT:
      return this.withContent;
    case WITHRESOURCESDATA:
      return this.withResourcesData;
    case WITHRESOURCESRECOGNITION:
      return this.withResourcesRecognition;
    case WITHRESOURCESALTERNATEDATA:
      return this.withResourcesAlternateData;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case WITHCONTENT:
      return isSetWithContent();
    case WITHRESOURCESDATA:
      return isSetWithResourcesData();
    case WITHRESOURCESRECOGNITION:
      return isSetWithResourcesRecognition();
    case WITHRESOURCESALTERNATEDATA:
      return isSetWithResourcesAlternateData();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHCONTENT:
          if (field.type == TType.BOOL) {
            this.withContent = iprot.readBool();
            this.__isset_withContent = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRESOURCESDATA:
          if (field.type == TType.BOOL) {
            this.withResourcesData = iprot.readBool();
            this.__isset_withResourcesData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRESOURCESRECOGNITION:
          if (field.type == TType.BOOL) {
            this.withResourcesRecognition = iprot.readBool();
            this.__isset_withResourcesRecognition = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRESOURCESALTERNATEDATA:
          if (field.type == TType.BOOL) {
            this.withResourcesAlternateData = iprot.readBool();
            this.__isset_withResourcesAlternateData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(WITH_CONTENT_FIELD_DESC);
    oprot.writeBool(this.withContent);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RESOURCES_DATA_FIELD_DESC);
    oprot.writeBool(this.withResourcesData);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RESOURCES_RECOGNITION_FIELD_DESC);
    oprot.writeBool(this.withResourcesRecognition);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RESOURCES_ALTERNATE_DATA_FIELD_DESC);
    oprot.writeBool(this.withResourcesAlternateData);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "withContent:";
    ret += this.withContent;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withResourcesData:";
    ret += this.withResourcesData;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withResourcesRecognition:";
    ret += this.withResourcesRecognition;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withResourcesAlternateData:";
    ret += this.withResourcesAlternateData;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Note;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Note));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNote_result, metaDataMap);
  }

  public function getNote_result() {
  }

  public function get success():Note {
    return this._success;
  }

  public function set success(success:Note):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Note();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNote_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteApplicationData_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteApplicationData_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteApplicationData_args, metaDataMap);
  }

  public function getNoteApplicationData_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteApplicationData_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteApplicationData_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteApplicationData_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:LazyMap;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, LazyMap));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteApplicationData_result, metaDataMap);
  }

  public function getNoteApplicationData_result() {
  }

  public function get success():LazyMap {
    return this._success;
  }

  public function set success(success:LazyMap):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new LazyMap();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteApplicationData_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteApplicationDataEntry_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteApplicationDataEntry_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const KEY_FIELD_DESC:TField = new TField("key", TType.STRING, 3);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _key:String;
  public static const KEY:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[KEY] = new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteApplicationDataEntry_args, metaDataMap);
  }

  public function getNoteApplicationDataEntry_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get key():String {
    return this._key;
  }

  public function set key(key:String):void {
    this._key = key;
  }

  public function unsetKey():void {
    this.key = null;
  }

  // Returns true if field key is set (has been assigned a value) and false otherwise
  public function isSetKey():Boolean {
    return this.key != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        this.key = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case KEY:
      return this.key;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case KEY:
      return isSetKey();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEY:
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteApplicationDataEntry_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "key:";
    if (this.key == null) {
      ret += "null";
    } else {
      ret += this.key;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteApplicationDataEntry_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteApplicationDataEntry_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteApplicationDataEntry_result, metaDataMap);
  }

  public function getNoteApplicationDataEntry_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteApplicationDataEntry_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setNoteApplicationDataEntry_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("setNoteApplicationDataEntry_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const KEY_FIELD_DESC:TField = new TField("key", TType.STRING, 3);
  private static const VALUE_FIELD_DESC:TField = new TField("value", TType.STRING, 4);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _key:String;
  public static const KEY:int = 3;
  private var _value:String;
  public static const VALUE:int = 4;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[KEY] = new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[VALUE] = new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(setNoteApplicationDataEntry_args, metaDataMap);
  }

  public function setNoteApplicationDataEntry_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get key():String {
    return this._key;
  }

  public function set key(key:String):void {
    this._key = key;
  }

  public function unsetKey():void {
    this.key = null;
  }

  // Returns true if field key is set (has been assigned a value) and false otherwise
  public function isSetKey():Boolean {
    return this.key != null;
  }

  public function get value():String {
    return this._value;
  }

  public function set value(value:String):void {
    this._value = value;
  }

  public function unsetValue():void {
    this.value = null;
  }

  // Returns true if field value is set (has been assigned a value) and false otherwise
  public function isSetValue():Boolean {
    return this.value != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        this.key = value;
      }
      break;

    case VALUE:
      if (value == null) {
        unsetValue();
      } else {
        this.value = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case KEY:
      return this.key;
    case VALUE:
      return this.value;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case KEY:
      return isSetKey();
    case VALUE:
      return isSetValue();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEY:
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    if (this.value != null) {
      oprot.writeFieldBegin(VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("setNoteApplicationDataEntry_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "key:";
    if (this.key == null) {
      ret += "null";
    } else {
      ret += this.key;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "value:";
    if (this.value == null) {
      ret += "null";
    } else {
      ret += this.value;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setNoteApplicationDataEntry_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("setNoteApplicationDataEntry_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(setNoteApplicationDataEntry_result, metaDataMap);
  }

  public function setNoteApplicationDataEntry_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("setNoteApplicationDataEntry_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unsetNoteApplicationDataEntry_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("unsetNoteApplicationDataEntry_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const KEY_FIELD_DESC:TField = new TField("key", TType.STRING, 3);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _key:String;
  public static const KEY:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[KEY] = new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(unsetNoteApplicationDataEntry_args, metaDataMap);
  }

  public function unsetNoteApplicationDataEntry_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get key():String {
    return this._key;
  }

  public function set key(key:String):void {
    this._key = key;
  }

  public function unsetKey():void {
    this.key = null;
  }

  // Returns true if field key is set (has been assigned a value) and false otherwise
  public function isSetKey():Boolean {
    return this.key != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        this.key = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case KEY:
      return this.key;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case KEY:
      return isSetKey();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEY:
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("unsetNoteApplicationDataEntry_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "key:";
    if (this.key == null) {
      ret += "null";
    } else {
      ret += this.key;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unsetNoteApplicationDataEntry_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("unsetNoteApplicationDataEntry_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(unsetNoteApplicationDataEntry_result, metaDataMap);
  }

  public function unsetNoteApplicationDataEntry_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("unsetNoteApplicationDataEntry_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteContent_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteContent_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteContent_args, metaDataMap);
  }

  public function getNoteContent_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteContent_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteContent_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteContent_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteContent_result, metaDataMap);
  }

  public function getNoteContent_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteContent_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteSearchText_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteSearchText_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const NOTE_ONLY_FIELD_DESC:TField = new TField("noteOnly", TType.BOOL, 3);
  private static const TOKENIZE_FOR_INDEXING_FIELD_DESC:TField = new TField("tokenizeForIndexing", TType.BOOL, 4);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _noteOnly:Boolean;
  public static const NOTEONLY:int = 3;
  private var _tokenizeForIndexing:Boolean;
  public static const TOKENIZEFORINDEXING:int = 4;

  private var __isset_noteOnly:Boolean = false;
  private var __isset_tokenizeForIndexing:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEONLY] = new FieldMetaData("noteOnly", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[TOKENIZEFORINDEXING] = new FieldMetaData("tokenizeForIndexing", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteSearchText_args, metaDataMap);
  }

  public function getNoteSearchText_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get noteOnly():Boolean {
    return this._noteOnly;
  }

  public function set noteOnly(noteOnly:Boolean):void {
    this._noteOnly = noteOnly;
    this.__isset_noteOnly = true;
  }

  public function unsetNoteOnly():void {
    this.__isset_noteOnly = false;
  }

  // Returns true if field noteOnly is set (has been assigned a value) and false otherwise
  public function isSetNoteOnly():Boolean {
    return this.__isset_noteOnly;
  }

  public function get tokenizeForIndexing():Boolean {
    return this._tokenizeForIndexing;
  }

  public function set tokenizeForIndexing(tokenizeForIndexing:Boolean):void {
    this._tokenizeForIndexing = tokenizeForIndexing;
    this.__isset_tokenizeForIndexing = true;
  }

  public function unsetTokenizeForIndexing():void {
    this.__isset_tokenizeForIndexing = false;
  }

  // Returns true if field tokenizeForIndexing is set (has been assigned a value) and false otherwise
  public function isSetTokenizeForIndexing():Boolean {
    return this.__isset_tokenizeForIndexing;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case NOTEONLY:
      if (value == null) {
        unsetNoteOnly();
      } else {
        this.noteOnly = value;
      }
      break;

    case TOKENIZEFORINDEXING:
      if (value == null) {
        unsetTokenizeForIndexing();
      } else {
        this.tokenizeForIndexing = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case NOTEONLY:
      return this.noteOnly;
    case TOKENIZEFORINDEXING:
      return this.tokenizeForIndexing;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case NOTEONLY:
      return isSetNoteOnly();
    case TOKENIZEFORINDEXING:
      return isSetTokenizeForIndexing();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEONLY:
          if (field.type == TType.BOOL) {
            this.noteOnly = iprot.readBool();
            this.__isset_noteOnly = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TOKENIZEFORINDEXING:
          if (field.type == TType.BOOL) {
            this.tokenizeForIndexing = iprot.readBool();
            this.__isset_tokenizeForIndexing = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(NOTE_ONLY_FIELD_DESC);
    oprot.writeBool(this.noteOnly);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(TOKENIZE_FOR_INDEXING_FIELD_DESC);
    oprot.writeBool(this.tokenizeForIndexing);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteSearchText_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "noteOnly:";
    ret += this.noteOnly;
    first = false;
    if (!first) ret +=  ", ";
    ret += "tokenizeForIndexing:";
    ret += this.tokenizeForIndexing;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteSearchText_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteSearchText_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteSearchText_result, metaDataMap);
  }

  public function getNoteSearchText_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteSearchText_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceSearchText_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceSearchText_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceSearchText_args, metaDataMap);
  }

  public function getResourceSearchText_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceSearchText_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceSearchText_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceSearchText_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceSearchText_result, metaDataMap);
  }

  public function getResourceSearchText_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceSearchText_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteTagNames_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteTagNames_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteTagNames_args, metaDataMap);
  }

  public function getNoteTagNames_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteTagNames_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteTagNames_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteTagNames_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteTagNames_result, metaDataMap);
  }

  public function getNoteTagNames_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list949:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i950:int = 0; _i950 < _list949.size; ++_i950)
              {
                var _elem951:String;
                _elem951 = iprot.readString();
                this.success.push(_elem951);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for each (var elem952:* in this.success)        {
          oprot.writeString(elem952);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteTagNames_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTE_FIELD_DESC:TField = new TField("note", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _note:Note;
  public static const NOTE:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTE] = new FieldMetaData("note", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Note));
  }
  {
    FieldMetaData.addStructMetaDataMap(createNote_args, metaDataMap);
  }

  public function createNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get note():Note {
    return this._note;
  }

  public function set note(note:Note):void {
    this._note = note;
  }

  public function unsetNote():void {
    this.note = null;
  }

  // Returns true if field note is set (has been assigned a value) and false otherwise
  public function isSetNote():Boolean {
    return this.note != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTE:
      if (value == null) {
        unsetNote();
      } else {
        this.note = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTE:
      return this.note;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTE:
      return isSetNote();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTE:
          if (field.type == TType.STRUCT) {
            this.note = new Note();
            this.note.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.note != null) {
      oprot.writeFieldBegin(NOTE_FIELD_DESC);
      this.note.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "note:";
    if (this.note == null) {
      ret += "null";
    } else {
      ret += this.note;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Note;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Note));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(createNote_result, metaDataMap);
  }

  public function createNote_result() {
  }

  public function get success():Note {
    return this._success;
  }

  public function set success(success:Note):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Note();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createNote_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTE_FIELD_DESC:TField = new TField("note", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _note:Note;
  public static const NOTE:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTE] = new FieldMetaData("note", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Note));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateNote_args, metaDataMap);
  }

  public function updateNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get note():Note {
    return this._note;
  }

  public function set note(note:Note):void {
    this._note = note;
  }

  public function unsetNote():void {
    this.note = null;
  }

  // Returns true if field note is set (has been assigned a value) and false otherwise
  public function isSetNote():Boolean {
    return this.note != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTE:
      if (value == null) {
        unsetNote();
      } else {
        this.note = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTE:
      return this.note;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTE:
      return isSetNote();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTE:
          if (field.type == TType.STRUCT) {
            this.note = new Note();
            this.note.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.note != null) {
      oprot.writeFieldBegin(NOTE_FIELD_DESC);
      this.note.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "note:";
    if (this.note == null) {
      ret += "null";
    } else {
      ret += this.note;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Note;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Note));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateNote_result, metaDataMap);
  }

  public function updateNote_result() {
  }

  public function get success():Note {
    return this._success;
  }

  public function set success(success:Note):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Note();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateNote_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class deleteNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("deleteNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(deleteNote_args, metaDataMap);
  }

  public function deleteNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("deleteNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class deleteNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("deleteNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(deleteNote_result, metaDataMap);
  }

  public function deleteNote_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("deleteNote_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeNote_args, metaDataMap);
  }

  public function expungeNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeNote_result, metaDataMap);
  }

  public function expungeNote_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeNote_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeNotes_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeNotes_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTE_GUIDS_FIELD_DESC:TField = new TField("noteGuids", TType.LIST, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _noteGuids:Array;
  public static const NOTEGUIDS:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEGUIDS] = new FieldMetaData("noteGuids", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeNotes_args, metaDataMap);
  }

  public function expungeNotes_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get noteGuids():Array {
    return this._noteGuids;
  }

  public function set noteGuids(noteGuids:Array):void {
    this._noteGuids = noteGuids;
  }

  public function unsetNoteGuids():void {
    this.noteGuids = null;
  }

  // Returns true if field noteGuids is set (has been assigned a value) and false otherwise
  public function isSetNoteGuids():Boolean {
    return this.noteGuids != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEGUIDS:
      if (value == null) {
        unsetNoteGuids();
      } else {
        this.noteGuids = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEGUIDS:
      return this.noteGuids;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEGUIDS:
      return isSetNoteGuids();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEGUIDS:
          if (field.type == TType.LIST) {
            {
              var _list979:TList = iprot.readListBegin();
              this.noteGuids = new Array();
              for (var _i980:int = 0; _i980 < _list979.size; ++_i980)
              {
                var _elem981:String;
                _elem981 = iprot.readString();
                this.noteGuids.push(_elem981);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.noteGuids != null) {
      oprot.writeFieldBegin(NOTE_GUIDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.noteGuids.length));
        for each (var elem982:* in this.noteGuids)        {
          oprot.writeString(elem982);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeNotes_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "noteGuids:";
    if (this.noteGuids == null) {
      ret += "null";
    } else {
      ret += this.noteGuids;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeNotes_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeNotes_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeNotes_result, metaDataMap);
  }

  public function expungeNotes_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeNotes_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeInactiveNotes_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeInactiveNotes_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeInactiveNotes_args, metaDataMap);
  }

  public function expungeInactiveNotes_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeInactiveNotes_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeInactiveNotes_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeInactiveNotes_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeInactiveNotes_result, metaDataMap);
  }

  public function expungeInactiveNotes_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeInactiveNotes_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class copyNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("copyNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTE_GUID_FIELD_DESC:TField = new TField("noteGuid", TType.STRING, 2);
  private static const TO_NOTEBOOK_GUID_FIELD_DESC:TField = new TField("toNotebookGuid", TType.STRING, 3);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _noteGuid:String;
  public static const NOTEGUID:int = 2;
  private var _toNotebookGuid:String;
  public static const TONOTEBOOKGUID:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEGUID] = new FieldMetaData("noteGuid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[TONOTEBOOKGUID] = new FieldMetaData("toNotebookGuid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(copyNote_args, metaDataMap);
  }

  public function copyNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get noteGuid():String {
    return this._noteGuid;
  }

  public function set noteGuid(noteGuid:String):void {
    this._noteGuid = noteGuid;
  }

  public function unsetNoteGuid():void {
    this.noteGuid = null;
  }

  // Returns true if field noteGuid is set (has been assigned a value) and false otherwise
  public function isSetNoteGuid():Boolean {
    return this.noteGuid != null;
  }

  public function get toNotebookGuid():String {
    return this._toNotebookGuid;
  }

  public function set toNotebookGuid(toNotebookGuid:String):void {
    this._toNotebookGuid = toNotebookGuid;
  }

  public function unsetToNotebookGuid():void {
    this.toNotebookGuid = null;
  }

  // Returns true if field toNotebookGuid is set (has been assigned a value) and false otherwise
  public function isSetToNotebookGuid():Boolean {
    return this.toNotebookGuid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEGUID:
      if (value == null) {
        unsetNoteGuid();
      } else {
        this.noteGuid = value;
      }
      break;

    case TONOTEBOOKGUID:
      if (value == null) {
        unsetToNotebookGuid();
      } else {
        this.toNotebookGuid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEGUID:
      return this.noteGuid;
    case TONOTEBOOKGUID:
      return this.toNotebookGuid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEGUID:
      return isSetNoteGuid();
    case TONOTEBOOKGUID:
      return isSetToNotebookGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEGUID:
          if (field.type == TType.STRING) {
            this.noteGuid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case TONOTEBOOKGUID:
          if (field.type == TType.STRING) {
            this.toNotebookGuid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.noteGuid != null) {
      oprot.writeFieldBegin(NOTE_GUID_FIELD_DESC);
      oprot.writeString(this.noteGuid);
      oprot.writeFieldEnd();
    }
    if (this.toNotebookGuid != null) {
      oprot.writeFieldBegin(TO_NOTEBOOK_GUID_FIELD_DESC);
      oprot.writeString(this.toNotebookGuid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("copyNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "noteGuid:";
    if (this.noteGuid == null) {
      ret += "null";
    } else {
      ret += this.noteGuid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "toNotebookGuid:";
    if (this.toNotebookGuid == null) {
      ret += "null";
    } else {
      ret += this.toNotebookGuid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class copyNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("copyNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Note;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Note));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(copyNote_result, metaDataMap);
  }

  public function copyNote_result() {
  }

  public function get success():Note {
    return this._success;
  }

  public function set success(success:Note):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Note();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("copyNote_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listNoteVersions_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listNoteVersions_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTE_GUID_FIELD_DESC:TField = new TField("noteGuid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _noteGuid:String;
  public static const NOTEGUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEGUID] = new FieldMetaData("noteGuid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(listNoteVersions_args, metaDataMap);
  }

  public function listNoteVersions_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get noteGuid():String {
    return this._noteGuid;
  }

  public function set noteGuid(noteGuid:String):void {
    this._noteGuid = noteGuid;
  }

  public function unsetNoteGuid():void {
    this.noteGuid = null;
  }

  // Returns true if field noteGuid is set (has been assigned a value) and false otherwise
  public function isSetNoteGuid():Boolean {
    return this.noteGuid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEGUID:
      if (value == null) {
        unsetNoteGuid();
      } else {
        this.noteGuid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEGUID:
      return this.noteGuid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEGUID:
      return isSetNoteGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEGUID:
          if (field.type == TType.STRING) {
            this.noteGuid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.noteGuid != null) {
      oprot.writeFieldBegin(NOTE_GUID_FIELD_DESC);
      oprot.writeString(this.noteGuid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listNoteVersions_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "noteGuid:";
    if (this.noteGuid == null) {
      ret += "null";
    } else {
      ret += this.noteGuid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listNoteVersions_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listNoteVersions_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, NoteVersionId)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(listNoteVersions_result, metaDataMap);
  }

  public function listNoteVersions_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list1004:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i1005:int = 0; _i1005 < _list1004.size; ++_i1005)
              {
                var _elem1006:NoteVersionId;
                _elem1006 = new NoteVersionId();
                _elem1006.read(iprot);
                this.success.push(_elem1006);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem1007:* in this.success)        {
          elem1007.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listNoteVersions_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteVersion_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteVersion_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTE_GUID_FIELD_DESC:TField = new TField("noteGuid", TType.STRING, 2);
  private static const UPDATE_SEQUENCE_NUM_FIELD_DESC:TField = new TField("updateSequenceNum", TType.I32, 3);
  private static const WITH_RESOURCES_DATA_FIELD_DESC:TField = new TField("withResourcesData", TType.BOOL, 4);
  private static const WITH_RESOURCES_RECOGNITION_FIELD_DESC:TField = new TField("withResourcesRecognition", TType.BOOL, 5);
  private static const WITH_RESOURCES_ALTERNATE_DATA_FIELD_DESC:TField = new TField("withResourcesAlternateData", TType.BOOL, 6);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _noteGuid:String;
  public static const NOTEGUID:int = 2;
  private var _updateSequenceNum:int;
  public static const UPDATESEQUENCENUM:int = 3;
  private var _withResourcesData:Boolean;
  public static const WITHRESOURCESDATA:int = 4;
  private var _withResourcesRecognition:Boolean;
  public static const WITHRESOURCESRECOGNITION:int = 5;
  private var _withResourcesAlternateData:Boolean;
  public static const WITHRESOURCESALTERNATEDATA:int = 6;

  private var __isset_updateSequenceNum:Boolean = false;
  private var __isset_withResourcesData:Boolean = false;
  private var __isset_withResourcesRecognition:Boolean = false;
  private var __isset_withResourcesAlternateData:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEGUID] = new FieldMetaData("noteGuid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[UPDATESEQUENCENUM] = new FieldMetaData("updateSequenceNum", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[WITHRESOURCESDATA] = new FieldMetaData("withResourcesData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHRESOURCESRECOGNITION] = new FieldMetaData("withResourcesRecognition", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHRESOURCESALTERNATEDATA] = new FieldMetaData("withResourcesAlternateData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteVersion_args, metaDataMap);
  }

  public function getNoteVersion_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get noteGuid():String {
    return this._noteGuid;
  }

  public function set noteGuid(noteGuid:String):void {
    this._noteGuid = noteGuid;
  }

  public function unsetNoteGuid():void {
    this.noteGuid = null;
  }

  // Returns true if field noteGuid is set (has been assigned a value) and false otherwise
  public function isSetNoteGuid():Boolean {
    return this.noteGuid != null;
  }

  public function get updateSequenceNum():int {
    return this._updateSequenceNum;
  }

  public function set updateSequenceNum(updateSequenceNum:int):void {
    this._updateSequenceNum = updateSequenceNum;
    this.__isset_updateSequenceNum = true;
  }

  public function unsetUpdateSequenceNum():void {
    this.__isset_updateSequenceNum = false;
  }

  // Returns true if field updateSequenceNum is set (has been assigned a value) and false otherwise
  public function isSetUpdateSequenceNum():Boolean {
    return this.__isset_updateSequenceNum;
  }

  public function get withResourcesData():Boolean {
    return this._withResourcesData;
  }

  public function set withResourcesData(withResourcesData:Boolean):void {
    this._withResourcesData = withResourcesData;
    this.__isset_withResourcesData = true;
  }

  public function unsetWithResourcesData():void {
    this.__isset_withResourcesData = false;
  }

  // Returns true if field withResourcesData is set (has been assigned a value) and false otherwise
  public function isSetWithResourcesData():Boolean {
    return this.__isset_withResourcesData;
  }

  public function get withResourcesRecognition():Boolean {
    return this._withResourcesRecognition;
  }

  public function set withResourcesRecognition(withResourcesRecognition:Boolean):void {
    this._withResourcesRecognition = withResourcesRecognition;
    this.__isset_withResourcesRecognition = true;
  }

  public function unsetWithResourcesRecognition():void {
    this.__isset_withResourcesRecognition = false;
  }

  // Returns true if field withResourcesRecognition is set (has been assigned a value) and false otherwise
  public function isSetWithResourcesRecognition():Boolean {
    return this.__isset_withResourcesRecognition;
  }

  public function get withResourcesAlternateData():Boolean {
    return this._withResourcesAlternateData;
  }

  public function set withResourcesAlternateData(withResourcesAlternateData:Boolean):void {
    this._withResourcesAlternateData = withResourcesAlternateData;
    this.__isset_withResourcesAlternateData = true;
  }

  public function unsetWithResourcesAlternateData():void {
    this.__isset_withResourcesAlternateData = false;
  }

  // Returns true if field withResourcesAlternateData is set (has been assigned a value) and false otherwise
  public function isSetWithResourcesAlternateData():Boolean {
    return this.__isset_withResourcesAlternateData;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEGUID:
      if (value == null) {
        unsetNoteGuid();
      } else {
        this.noteGuid = value;
      }
      break;

    case UPDATESEQUENCENUM:
      if (value == null) {
        unsetUpdateSequenceNum();
      } else {
        this.updateSequenceNum = value;
      }
      break;

    case WITHRESOURCESDATA:
      if (value == null) {
        unsetWithResourcesData();
      } else {
        this.withResourcesData = value;
      }
      break;

    case WITHRESOURCESRECOGNITION:
      if (value == null) {
        unsetWithResourcesRecognition();
      } else {
        this.withResourcesRecognition = value;
      }
      break;

    case WITHRESOURCESALTERNATEDATA:
      if (value == null) {
        unsetWithResourcesAlternateData();
      } else {
        this.withResourcesAlternateData = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEGUID:
      return this.noteGuid;
    case UPDATESEQUENCENUM:
      return this.updateSequenceNum;
    case WITHRESOURCESDATA:
      return this.withResourcesData;
    case WITHRESOURCESRECOGNITION:
      return this.withResourcesRecognition;
    case WITHRESOURCESALTERNATEDATA:
      return this.withResourcesAlternateData;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEGUID:
      return isSetNoteGuid();
    case UPDATESEQUENCENUM:
      return isSetUpdateSequenceNum();
    case WITHRESOURCESDATA:
      return isSetWithResourcesData();
    case WITHRESOURCESRECOGNITION:
      return isSetWithResourcesRecognition();
    case WITHRESOURCESALTERNATEDATA:
      return isSetWithResourcesAlternateData();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEGUID:
          if (field.type == TType.STRING) {
            this.noteGuid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case UPDATESEQUENCENUM:
          if (field.type == TType.I32) {
            this.updateSequenceNum = iprot.readI32();
            this.__isset_updateSequenceNum = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRESOURCESDATA:
          if (field.type == TType.BOOL) {
            this.withResourcesData = iprot.readBool();
            this.__isset_withResourcesData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRESOURCESRECOGNITION:
          if (field.type == TType.BOOL) {
            this.withResourcesRecognition = iprot.readBool();
            this.__isset_withResourcesRecognition = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRESOURCESALTERNATEDATA:
          if (field.type == TType.BOOL) {
            this.withResourcesAlternateData = iprot.readBool();
            this.__isset_withResourcesAlternateData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.noteGuid != null) {
      oprot.writeFieldBegin(NOTE_GUID_FIELD_DESC);
      oprot.writeString(this.noteGuid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(UPDATE_SEQUENCE_NUM_FIELD_DESC);
    oprot.writeI32(this.updateSequenceNum);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RESOURCES_DATA_FIELD_DESC);
    oprot.writeBool(this.withResourcesData);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RESOURCES_RECOGNITION_FIELD_DESC);
    oprot.writeBool(this.withResourcesRecognition);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RESOURCES_ALTERNATE_DATA_FIELD_DESC);
    oprot.writeBool(this.withResourcesAlternateData);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteVersion_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "noteGuid:";
    if (this.noteGuid == null) {
      ret += "null";
    } else {
      ret += this.noteGuid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "updateSequenceNum:";
    ret += this.updateSequenceNum;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withResourcesData:";
    ret += this.withResourcesData;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withResourcesRecognition:";
    ret += this.withResourcesRecognition;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withResourcesAlternateData:";
    ret += this.withResourcesAlternateData;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteVersion_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteVersion_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Note;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Note));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteVersion_result, metaDataMap);
  }

  public function getNoteVersion_result() {
  }

  public function get success():Note {
    return this._success;
  }

  public function set success(success:Note):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Note();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteVersion_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResource_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResource_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const WITH_DATA_FIELD_DESC:TField = new TField("withData", TType.BOOL, 3);
  private static const WITH_RECOGNITION_FIELD_DESC:TField = new TField("withRecognition", TType.BOOL, 4);
  private static const WITH_ATTRIBUTES_FIELD_DESC:TField = new TField("withAttributes", TType.BOOL, 5);
  private static const WITH_ALTERNATE_DATA_FIELD_DESC:TField = new TField("withAlternateData", TType.BOOL, 6);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _withData:Boolean;
  public static const WITHDATA:int = 3;
  private var _withRecognition:Boolean;
  public static const WITHRECOGNITION:int = 4;
  private var _withAttributes:Boolean;
  public static const WITHATTRIBUTES:int = 5;
  private var _withAlternateData:Boolean;
  public static const WITHALTERNATEDATA:int = 6;

  private var __isset_withData:Boolean = false;
  private var __isset_withRecognition:Boolean = false;
  private var __isset_withAttributes:Boolean = false;
  private var __isset_withAlternateData:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[WITHDATA] = new FieldMetaData("withData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHRECOGNITION] = new FieldMetaData("withRecognition", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHATTRIBUTES] = new FieldMetaData("withAttributes", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHALTERNATEDATA] = new FieldMetaData("withAlternateData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResource_args, metaDataMap);
  }

  public function getResource_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get withData():Boolean {
    return this._withData;
  }

  public function set withData(withData:Boolean):void {
    this._withData = withData;
    this.__isset_withData = true;
  }

  public function unsetWithData():void {
    this.__isset_withData = false;
  }

  // Returns true if field withData is set (has been assigned a value) and false otherwise
  public function isSetWithData():Boolean {
    return this.__isset_withData;
  }

  public function get withRecognition():Boolean {
    return this._withRecognition;
  }

  public function set withRecognition(withRecognition:Boolean):void {
    this._withRecognition = withRecognition;
    this.__isset_withRecognition = true;
  }

  public function unsetWithRecognition():void {
    this.__isset_withRecognition = false;
  }

  // Returns true if field withRecognition is set (has been assigned a value) and false otherwise
  public function isSetWithRecognition():Boolean {
    return this.__isset_withRecognition;
  }

  public function get withAttributes():Boolean {
    return this._withAttributes;
  }

  public function set withAttributes(withAttributes:Boolean):void {
    this._withAttributes = withAttributes;
    this.__isset_withAttributes = true;
  }

  public function unsetWithAttributes():void {
    this.__isset_withAttributes = false;
  }

  // Returns true if field withAttributes is set (has been assigned a value) and false otherwise
  public function isSetWithAttributes():Boolean {
    return this.__isset_withAttributes;
  }

  public function get withAlternateData():Boolean {
    return this._withAlternateData;
  }

  public function set withAlternateData(withAlternateData:Boolean):void {
    this._withAlternateData = withAlternateData;
    this.__isset_withAlternateData = true;
  }

  public function unsetWithAlternateData():void {
    this.__isset_withAlternateData = false;
  }

  // Returns true if field withAlternateData is set (has been assigned a value) and false otherwise
  public function isSetWithAlternateData():Boolean {
    return this.__isset_withAlternateData;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case WITHDATA:
      if (value == null) {
        unsetWithData();
      } else {
        this.withData = value;
      }
      break;

    case WITHRECOGNITION:
      if (value == null) {
        unsetWithRecognition();
      } else {
        this.withRecognition = value;
      }
      break;

    case WITHATTRIBUTES:
      if (value == null) {
        unsetWithAttributes();
      } else {
        this.withAttributes = value;
      }
      break;

    case WITHALTERNATEDATA:
      if (value == null) {
        unsetWithAlternateData();
      } else {
        this.withAlternateData = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case WITHDATA:
      return this.withData;
    case WITHRECOGNITION:
      return this.withRecognition;
    case WITHATTRIBUTES:
      return this.withAttributes;
    case WITHALTERNATEDATA:
      return this.withAlternateData;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case WITHDATA:
      return isSetWithData();
    case WITHRECOGNITION:
      return isSetWithRecognition();
    case WITHATTRIBUTES:
      return isSetWithAttributes();
    case WITHALTERNATEDATA:
      return isSetWithAlternateData();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHDATA:
          if (field.type == TType.BOOL) {
            this.withData = iprot.readBool();
            this.__isset_withData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRECOGNITION:
          if (field.type == TType.BOOL) {
            this.withRecognition = iprot.readBool();
            this.__isset_withRecognition = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHATTRIBUTES:
          if (field.type == TType.BOOL) {
            this.withAttributes = iprot.readBool();
            this.__isset_withAttributes = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHALTERNATEDATA:
          if (field.type == TType.BOOL) {
            this.withAlternateData = iprot.readBool();
            this.__isset_withAlternateData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(WITH_DATA_FIELD_DESC);
    oprot.writeBool(this.withData);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RECOGNITION_FIELD_DESC);
    oprot.writeBool(this.withRecognition);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_ATTRIBUTES_FIELD_DESC);
    oprot.writeBool(this.withAttributes);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_ALTERNATE_DATA_FIELD_DESC);
    oprot.writeBool(this.withAlternateData);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResource_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "withData:";
    ret += this.withData;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withRecognition:";
    ret += this.withRecognition;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withAttributes:";
    ret += this.withAttributes;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withAlternateData:";
    ret += this.withAlternateData;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResource_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResource_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Resource;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Resource));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResource_result, metaDataMap);
  }

  public function getResource_result() {
  }

  public function get success():Resource {
    return this._success;
  }

  public function set success(success:Resource):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Resource();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResource_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceApplicationData_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceApplicationData_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceApplicationData_args, metaDataMap);
  }

  public function getResourceApplicationData_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceApplicationData_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceApplicationData_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceApplicationData_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:LazyMap;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, LazyMap));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceApplicationData_result, metaDataMap);
  }

  public function getResourceApplicationData_result() {
  }

  public function get success():LazyMap {
    return this._success;
  }

  public function set success(success:LazyMap):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new LazyMap();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceApplicationData_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceApplicationDataEntry_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceApplicationDataEntry_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const KEY_FIELD_DESC:TField = new TField("key", TType.STRING, 3);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _key:String;
  public static const KEY:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[KEY] = new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceApplicationDataEntry_args, metaDataMap);
  }

  public function getResourceApplicationDataEntry_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get key():String {
    return this._key;
  }

  public function set key(key:String):void {
    this._key = key;
  }

  public function unsetKey():void {
    this.key = null;
  }

  // Returns true if field key is set (has been assigned a value) and false otherwise
  public function isSetKey():Boolean {
    return this.key != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        this.key = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case KEY:
      return this.key;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case KEY:
      return isSetKey();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEY:
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceApplicationDataEntry_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "key:";
    if (this.key == null) {
      ret += "null";
    } else {
      ret += this.key;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceApplicationDataEntry_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceApplicationDataEntry_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceApplicationDataEntry_result, metaDataMap);
  }

  public function getResourceApplicationDataEntry_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceApplicationDataEntry_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setResourceApplicationDataEntry_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("setResourceApplicationDataEntry_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const KEY_FIELD_DESC:TField = new TField("key", TType.STRING, 3);
  private static const VALUE_FIELD_DESC:TField = new TField("value", TType.STRING, 4);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _key:String;
  public static const KEY:int = 3;
  private var _value:String;
  public static const VALUE:int = 4;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[KEY] = new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[VALUE] = new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(setResourceApplicationDataEntry_args, metaDataMap);
  }

  public function setResourceApplicationDataEntry_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get key():String {
    return this._key;
  }

  public function set key(key:String):void {
    this._key = key;
  }

  public function unsetKey():void {
    this.key = null;
  }

  // Returns true if field key is set (has been assigned a value) and false otherwise
  public function isSetKey():Boolean {
    return this.key != null;
  }

  public function get value():String {
    return this._value;
  }

  public function set value(value:String):void {
    this._value = value;
  }

  public function unsetValue():void {
    this.value = null;
  }

  // Returns true if field value is set (has been assigned a value) and false otherwise
  public function isSetValue():Boolean {
    return this.value != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        this.key = value;
      }
      break;

    case VALUE:
      if (value == null) {
        unsetValue();
      } else {
        this.value = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case KEY:
      return this.key;
    case VALUE:
      return this.value;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case KEY:
      return isSetKey();
    case VALUE:
      return isSetValue();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEY:
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case VALUE:
          if (field.type == TType.STRING) {
            this.value = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    if (this.value != null) {
      oprot.writeFieldBegin(VALUE_FIELD_DESC);
      oprot.writeString(this.value);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("setResourceApplicationDataEntry_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "key:";
    if (this.key == null) {
      ret += "null";
    } else {
      ret += this.key;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "value:";
    if (this.value == null) {
      ret += "null";
    } else {
      ret += this.value;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class setResourceApplicationDataEntry_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("setResourceApplicationDataEntry_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(setResourceApplicationDataEntry_result, metaDataMap);
  }

  public function setResourceApplicationDataEntry_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("setResourceApplicationDataEntry_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unsetResourceApplicationDataEntry_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("unsetResourceApplicationDataEntry_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);
  private static const KEY_FIELD_DESC:TField = new TField("key", TType.STRING, 3);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;
  private var _key:String;
  public static const KEY:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[KEY] = new FieldMetaData("key", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(unsetResourceApplicationDataEntry_args, metaDataMap);
  }

  public function unsetResourceApplicationDataEntry_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get key():String {
    return this._key;
  }

  public function set key(key:String):void {
    this._key = key;
  }

  public function unsetKey():void {
    this.key = null;
  }

  // Returns true if field key is set (has been assigned a value) and false otherwise
  public function isSetKey():Boolean {
    return this.key != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case KEY:
      if (value == null) {
        unsetKey();
      } else {
        this.key = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    case KEY:
      return this.key;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    case KEY:
      return isSetKey();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case KEY:
          if (field.type == TType.STRING) {
            this.key = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    if (this.key != null) {
      oprot.writeFieldBegin(KEY_FIELD_DESC);
      oprot.writeString(this.key);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("unsetResourceApplicationDataEntry_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "key:";
    if (this.key == null) {
      ret += "null";
    } else {
      ret += this.key;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class unsetResourceApplicationDataEntry_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("unsetResourceApplicationDataEntry_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(unsetResourceApplicationDataEntry_result, metaDataMap);
  }

  public function unsetResourceApplicationDataEntry_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("unsetResourceApplicationDataEntry_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateResource_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateResource_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const RESOURCE_FIELD_DESC:TField = new TField("resource", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _resource:Resource;
  public static const RESOURCE:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[RESOURCE] = new FieldMetaData("resource", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Resource));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateResource_args, metaDataMap);
  }

  public function updateResource_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get resource():Resource {
    return this._resource;
  }

  public function set resource(resource:Resource):void {
    this._resource = resource;
  }

  public function unsetResource():void {
    this.resource = null;
  }

  // Returns true if field resource is set (has been assigned a value) and false otherwise
  public function isSetResource():Boolean {
    return this.resource != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case RESOURCE:
      if (value == null) {
        unsetResource();
      } else {
        this.resource = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case RESOURCE:
      return this.resource;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case RESOURCE:
      return isSetResource();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RESOURCE:
          if (field.type == TType.STRUCT) {
            this.resource = new Resource();
            this.resource.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.resource != null) {
      oprot.writeFieldBegin(RESOURCE_FIELD_DESC);
      this.resource.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateResource_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "resource:";
    if (this.resource == null) {
      ret += "null";
    } else {
      ret += this.resource;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateResource_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateResource_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateResource_result, metaDataMap);
  }

  public function updateResource_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateResource_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceData_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceData_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceData_args, metaDataMap);
  }

  public function getResourceData_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceData_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceData_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceData_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:ByteArray;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceData_result, metaDataMap);
  }

  public function getResourceData_result() {
  }

  public function get success():ByteArray {
    return this._success;
  }

  public function set success(success:ByteArray):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceData_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceByHash_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceByHash_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTE_GUID_FIELD_DESC:TField = new TField("noteGuid", TType.STRING, 2);
  private static const CONTENT_HASH_FIELD_DESC:TField = new TField("contentHash", TType.STRING, 3);
  private static const WITH_DATA_FIELD_DESC:TField = new TField("withData", TType.BOOL, 4);
  private static const WITH_RECOGNITION_FIELD_DESC:TField = new TField("withRecognition", TType.BOOL, 5);
  private static const WITH_ALTERNATE_DATA_FIELD_DESC:TField = new TField("withAlternateData", TType.BOOL, 6);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _noteGuid:String;
  public static const NOTEGUID:int = 2;
  private var _contentHash:ByteArray;
  public static const CONTENTHASH:int = 3;
  private var _withData:Boolean;
  public static const WITHDATA:int = 4;
  private var _withRecognition:Boolean;
  public static const WITHRECOGNITION:int = 5;
  private var _withAlternateData:Boolean;
  public static const WITHALTERNATEDATA:int = 6;

  private var __isset_withData:Boolean = false;
  private var __isset_withRecognition:Boolean = false;
  private var __isset_withAlternateData:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEGUID] = new FieldMetaData("noteGuid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[CONTENTHASH] = new FieldMetaData("contentHash", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[WITHDATA] = new FieldMetaData("withData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHRECOGNITION] = new FieldMetaData("withRecognition", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
    metaDataMap[WITHALTERNATEDATA] = new FieldMetaData("withAlternateData", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceByHash_args, metaDataMap);
  }

  public function getResourceByHash_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get noteGuid():String {
    return this._noteGuid;
  }

  public function set noteGuid(noteGuid:String):void {
    this._noteGuid = noteGuid;
  }

  public function unsetNoteGuid():void {
    this.noteGuid = null;
  }

  // Returns true if field noteGuid is set (has been assigned a value) and false otherwise
  public function isSetNoteGuid():Boolean {
    return this.noteGuid != null;
  }

  public function get contentHash():ByteArray {
    return this._contentHash;
  }

  public function set contentHash(contentHash:ByteArray):void {
    this._contentHash = contentHash;
  }

  public function unsetContentHash():void {
    this.contentHash = null;
  }

  // Returns true if field contentHash is set (has been assigned a value) and false otherwise
  public function isSetContentHash():Boolean {
    return this.contentHash != null;
  }

  public function get withData():Boolean {
    return this._withData;
  }

  public function set withData(withData:Boolean):void {
    this._withData = withData;
    this.__isset_withData = true;
  }

  public function unsetWithData():void {
    this.__isset_withData = false;
  }

  // Returns true if field withData is set (has been assigned a value) and false otherwise
  public function isSetWithData():Boolean {
    return this.__isset_withData;
  }

  public function get withRecognition():Boolean {
    return this._withRecognition;
  }

  public function set withRecognition(withRecognition:Boolean):void {
    this._withRecognition = withRecognition;
    this.__isset_withRecognition = true;
  }

  public function unsetWithRecognition():void {
    this.__isset_withRecognition = false;
  }

  // Returns true if field withRecognition is set (has been assigned a value) and false otherwise
  public function isSetWithRecognition():Boolean {
    return this.__isset_withRecognition;
  }

  public function get withAlternateData():Boolean {
    return this._withAlternateData;
  }

  public function set withAlternateData(withAlternateData:Boolean):void {
    this._withAlternateData = withAlternateData;
    this.__isset_withAlternateData = true;
  }

  public function unsetWithAlternateData():void {
    this.__isset_withAlternateData = false;
  }

  // Returns true if field withAlternateData is set (has been assigned a value) and false otherwise
  public function isSetWithAlternateData():Boolean {
    return this.__isset_withAlternateData;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEGUID:
      if (value == null) {
        unsetNoteGuid();
      } else {
        this.noteGuid = value;
      }
      break;

    case CONTENTHASH:
      if (value == null) {
        unsetContentHash();
      } else {
        this.contentHash = value;
      }
      break;

    case WITHDATA:
      if (value == null) {
        unsetWithData();
      } else {
        this.withData = value;
      }
      break;

    case WITHRECOGNITION:
      if (value == null) {
        unsetWithRecognition();
      } else {
        this.withRecognition = value;
      }
      break;

    case WITHALTERNATEDATA:
      if (value == null) {
        unsetWithAlternateData();
      } else {
        this.withAlternateData = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEGUID:
      return this.noteGuid;
    case CONTENTHASH:
      return this.contentHash;
    case WITHDATA:
      return this.withData;
    case WITHRECOGNITION:
      return this.withRecognition;
    case WITHALTERNATEDATA:
      return this.withAlternateData;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEGUID:
      return isSetNoteGuid();
    case CONTENTHASH:
      return isSetContentHash();
    case WITHDATA:
      return isSetWithData();
    case WITHRECOGNITION:
      return isSetWithRecognition();
    case WITHALTERNATEDATA:
      return isSetWithAlternateData();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEGUID:
          if (field.type == TType.STRING) {
            this.noteGuid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONTENTHASH:
          if (field.type == TType.STRING) {
            this.contentHash = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHDATA:
          if (field.type == TType.BOOL) {
            this.withData = iprot.readBool();
            this.__isset_withData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHRECOGNITION:
          if (field.type == TType.BOOL) {
            this.withRecognition = iprot.readBool();
            this.__isset_withRecognition = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case WITHALTERNATEDATA:
          if (field.type == TType.BOOL) {
            this.withAlternateData = iprot.readBool();
            this.__isset_withAlternateData = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.noteGuid != null) {
      oprot.writeFieldBegin(NOTE_GUID_FIELD_DESC);
      oprot.writeString(this.noteGuid);
      oprot.writeFieldEnd();
    }
    if (this.contentHash != null) {
      oprot.writeFieldBegin(CONTENT_HASH_FIELD_DESC);
      oprot.writeBinary(this.contentHash);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(WITH_DATA_FIELD_DESC);
    oprot.writeBool(this.withData);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_RECOGNITION_FIELD_DESC);
    oprot.writeBool(this.withRecognition);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(WITH_ALTERNATE_DATA_FIELD_DESC);
    oprot.writeBool(this.withAlternateData);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceByHash_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "noteGuid:";
    if (this.noteGuid == null) {
      ret += "null";
    } else {
      ret += this.noteGuid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "contentHash:";
    if (this.contentHash == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "withData:";
    ret += this.withData;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withRecognition:";
    ret += this.withRecognition;
    first = false;
    if (!first) ret +=  ", ";
    ret += "withAlternateData:";
    ret += this.withAlternateData;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceByHash_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceByHash_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:Resource;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Resource));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceByHash_result, metaDataMap);
  }

  public function getResourceByHash_result() {
  }

  public function get success():Resource {
    return this._success;
  }

  public function set success(success:Resource):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Resource();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceByHash_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceRecognition_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceRecognition_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceRecognition_args, metaDataMap);
  }

  public function getResourceRecognition_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceRecognition_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceRecognition_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceRecognition_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:ByteArray;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceRecognition_result, metaDataMap);
  }

  public function getResourceRecognition_result() {
  }

  public function get success():ByteArray {
    return this._success;
  }

  public function set success(success:ByteArray):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceRecognition_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceAlternateData_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceAlternateData_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceAlternateData_args, metaDataMap);
  }

  public function getResourceAlternateData_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceAlternateData_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceAlternateData_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceAlternateData_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:ByteArray;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceAlternateData_result, metaDataMap);
  }

  public function getResourceAlternateData_result() {
  }

  public function get success():ByteArray {
    return this._success;
  }

  public function set success(success:ByteArray):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeBinary(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceAlternateData_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceAttributes_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceAttributes_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceAttributes_args, metaDataMap);
  }

  public function getResourceAttributes_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceAttributes_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getResourceAttributes_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getResourceAttributes_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 3);

  private var _success:ResourceAttributes;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, ResourceAttributes));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getResourceAttributes_result, metaDataMap);
  }

  public function getResourceAttributes_result() {
  }

  public function get success():ResourceAttributes {
    return this._success;
  }

  public function set success(success:ResourceAttributes):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new ResourceAttributes();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getResourceAttributes_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAccountSize_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getAccountSize_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getAccountSize_args, metaDataMap);
  }

  public function getAccountSize_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getAccountSize_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAccountSize_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getAccountSize_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I64, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:BigInteger;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I64));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getAccountSize_result, metaDataMap);
  }

  public function getAccountSize_result() {
  }

  public function get success():BigInteger {
    return this._success;
  }

  public function set success(success:BigInteger):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I64) {
            this.success = iprot.readI64();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI64(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getAccountSize_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAds_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getAds_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const AD_PARAMETERS_FIELD_DESC:TField = new TField("adParameters", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _adParameters:AdParameters;
  public static const ADPARAMETERS:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[ADPARAMETERS] = new FieldMetaData("adParameters", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, AdParameters));
  }
  {
    FieldMetaData.addStructMetaDataMap(getAds_args, metaDataMap);
  }

  public function getAds_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get adParameters():AdParameters {
    return this._adParameters;
  }

  public function set adParameters(adParameters:AdParameters):void {
    this._adParameters = adParameters;
  }

  public function unsetAdParameters():void {
    this.adParameters = null;
  }

  // Returns true if field adParameters is set (has been assigned a value) and false otherwise
  public function isSetAdParameters():Boolean {
    return this.adParameters != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case ADPARAMETERS:
      if (value == null) {
        unsetAdParameters();
      } else {
        this.adParameters = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case ADPARAMETERS:
      return this.adParameters;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case ADPARAMETERS:
      return isSetAdParameters();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ADPARAMETERS:
          if (field.type == TType.STRUCT) {
            this.adParameters = new AdParameters();
            this.adParameters.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.adParameters != null) {
      oprot.writeFieldBegin(AD_PARAMETERS_FIELD_DESC);
      this.adParameters.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getAds_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "adParameters:";
    if (this.adParameters == null) {
      ret += "null";
    } else {
      ret += this.adParameters;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getAds_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getAds_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, Ad)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getAds_result, metaDataMap);
  }

  public function getAds_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list1105:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i1106:int = 0; _i1106 < _list1105.size; ++_i1106)
              {
                var _elem1107:Ad;
                _elem1107 = new Ad();
                _elem1107.read(iprot);
                this.success.push(_elem1107);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem1108:* in this.success)        {
          elem1108.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getAds_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRandomAd_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getRandomAd_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const AD_PARAMETERS_FIELD_DESC:TField = new TField("adParameters", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _adParameters:AdParameters;
  public static const ADPARAMETERS:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[ADPARAMETERS] = new FieldMetaData("adParameters", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, AdParameters));
  }
  {
    FieldMetaData.addStructMetaDataMap(getRandomAd_args, metaDataMap);
  }

  public function getRandomAd_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get adParameters():AdParameters {
    return this._adParameters;
  }

  public function set adParameters(adParameters:AdParameters):void {
    this._adParameters = adParameters;
  }

  public function unsetAdParameters():void {
    this.adParameters = null;
  }

  // Returns true if field adParameters is set (has been assigned a value) and false otherwise
  public function isSetAdParameters():Boolean {
    return this.adParameters != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case ADPARAMETERS:
      if (value == null) {
        unsetAdParameters();
      } else {
        this.adParameters = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case ADPARAMETERS:
      return this.adParameters;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case ADPARAMETERS:
      return isSetAdParameters();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case ADPARAMETERS:
          if (field.type == TType.STRUCT) {
            this.adParameters = new AdParameters();
            this.adParameters.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.adParameters != null) {
      oprot.writeFieldBegin(AD_PARAMETERS_FIELD_DESC);
      this.adParameters.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getRandomAd_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "adParameters:";
    if (this.adParameters == null) {
      ret += "null";
    } else {
      ret += this.adParameters;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getRandomAd_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getRandomAd_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:Ad;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Ad));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getRandomAd_result, metaDataMap);
  }

  public function getRandomAd_result() {
  }

  public function get success():Ad {
    return this._success;
  }

  public function set success(success:Ad):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Ad();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getRandomAd_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPublicNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getPublicNotebook_args");
  private static const USER_ID_FIELD_DESC:TField = new TField("userId", TType.I32, 1);
  private static const PUBLIC_URI_FIELD_DESC:TField = new TField("publicUri", TType.STRING, 2);

  private var _userId:int;
  public static const USERID:int = 1;
  private var _publicUri:String;
  public static const PUBLICURI:int = 2;

  private var __isset_userId:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[USERID] = new FieldMetaData("userId", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[PUBLICURI] = new FieldMetaData("publicUri", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getPublicNotebook_args, metaDataMap);
  }

  public function getPublicNotebook_args() {
  }

  public function get userId():int {
    return this._userId;
  }

  public function set userId(userId:int):void {
    this._userId = userId;
    this.__isset_userId = true;
  }

  public function unsetUserId():void {
    this.__isset_userId = false;
  }

  // Returns true if field userId is set (has been assigned a value) and false otherwise
  public function isSetUserId():Boolean {
    return this.__isset_userId;
  }

  public function get publicUri():String {
    return this._publicUri;
  }

  public function set publicUri(publicUri:String):void {
    this._publicUri = publicUri;
  }

  public function unsetPublicUri():void {
    this.publicUri = null;
  }

  // Returns true if field publicUri is set (has been assigned a value) and false otherwise
  public function isSetPublicUri():Boolean {
    return this.publicUri != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case USERID:
      if (value == null) {
        unsetUserId();
      } else {
        this.userId = value;
      }
      break;

    case PUBLICURI:
      if (value == null) {
        unsetPublicUri();
      } else {
        this.publicUri = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case USERID:
      return this.userId;
    case PUBLICURI:
      return this.publicUri;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case USERID:
      return isSetUserId();
    case PUBLICURI:
      return isSetPublicUri();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case USERID:
          if (field.type == TType.I32) {
            this.userId = iprot.readI32();
            this.__isset_userId = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PUBLICURI:
          if (field.type == TType.STRING) {
            this.publicUri = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldBegin(USER_ID_FIELD_DESC);
    oprot.writeI32(this.userId);
    oprot.writeFieldEnd();
    if (this.publicUri != null) {
      oprot.writeFieldBegin(PUBLIC_URI_FIELD_DESC);
      oprot.writeString(this.publicUri);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getPublicNotebook_args(");
    var first:Boolean = true;

    ret += "userId:";
    ret += this.userId;
    first = false;
    if (!first) ret +=  ", ";
    ret += "publicUri:";
    if (this.publicUri == null) {
      ret += "null";
    } else {
      ret += this.publicUri;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPublicNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getPublicNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);

  private var _success:Notebook;
  public static const SUCCESS:int = 0;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, Notebook));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getPublicNotebook_result, metaDataMap);
  }

  public function getPublicNotebook_result() {
  }

  public function get success():Notebook {
    return this._success;
  }

  public function set success(success:Notebook):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new Notebook();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getPublicNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createSharedNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createSharedNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const SHARED_NOTEBOOK_FIELD_DESC:TField = new TField("sharedNotebook", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _sharedNotebook:SharedNotebook;
  public static const SHAREDNOTEBOOK:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SHAREDNOTEBOOK] = new FieldMetaData("sharedNotebook", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SharedNotebook));
  }
  {
    FieldMetaData.addStructMetaDataMap(createSharedNotebook_args, metaDataMap);
  }

  public function createSharedNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get sharedNotebook():SharedNotebook {
    return this._sharedNotebook;
  }

  public function set sharedNotebook(sharedNotebook:SharedNotebook):void {
    this._sharedNotebook = sharedNotebook;
  }

  public function unsetSharedNotebook():void {
    this.sharedNotebook = null;
  }

  // Returns true if field sharedNotebook is set (has been assigned a value) and false otherwise
  public function isSetSharedNotebook():Boolean {
    return this.sharedNotebook != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case SHAREDNOTEBOOK:
      if (value == null) {
        unsetSharedNotebook();
      } else {
        this.sharedNotebook = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case SHAREDNOTEBOOK:
      return this.sharedNotebook;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case SHAREDNOTEBOOK:
      return isSetSharedNotebook();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SHAREDNOTEBOOK:
          if (field.type == TType.STRUCT) {
            this.sharedNotebook = new SharedNotebook();
            this.sharedNotebook.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.sharedNotebook != null) {
      oprot.writeFieldBegin(SHARED_NOTEBOOK_FIELD_DESC);
      this.sharedNotebook.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createSharedNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "sharedNotebook:";
    if (this.sharedNotebook == null) {
      ret += "null";
    } else {
      ret += this.sharedNotebook;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createSharedNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createSharedNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:SharedNotebook;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SharedNotebook));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(createSharedNotebook_result, metaDataMap);
  }

  public function createSharedNotebook_result() {
  }

  public function get success():SharedNotebook {
    return this._success;
  }

  public function set success(success:SharedNotebook):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SharedNotebook();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createSharedNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageToSharedNotebookMembers_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("sendMessageToSharedNotebookMembers_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const NOTEBOOK_GUID_FIELD_DESC:TField = new TField("notebookGuid", TType.STRING, 2);
  private static const MESSAGE_TEXT_FIELD_DESC:TField = new TField("messageText", TType.STRING, 3);
  private static const RECIPIENTS_FIELD_DESC:TField = new TField("recipients", TType.LIST, 4);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _notebookGuid:String;
  public static const NOTEBOOKGUID:int = 2;
  private var _messageText:String;
  public static const MESSAGETEXT:int = 3;
  private var _recipients:Array;
  public static const RECIPIENTS:int = 4;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEBOOKGUID] = new FieldMetaData("notebookGuid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[MESSAGETEXT] = new FieldMetaData("messageText", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[RECIPIENTS] = new FieldMetaData("recipients", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
  }
  {
    FieldMetaData.addStructMetaDataMap(sendMessageToSharedNotebookMembers_args, metaDataMap);
  }

  public function sendMessageToSharedNotebookMembers_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get notebookGuid():String {
    return this._notebookGuid;
  }

  public function set notebookGuid(notebookGuid:String):void {
    this._notebookGuid = notebookGuid;
  }

  public function unsetNotebookGuid():void {
    this.notebookGuid = null;
  }

  // Returns true if field notebookGuid is set (has been assigned a value) and false otherwise
  public function isSetNotebookGuid():Boolean {
    return this.notebookGuid != null;
  }

  public function get messageText():String {
    return this._messageText;
  }

  public function set messageText(messageText:String):void {
    this._messageText = messageText;
  }

  public function unsetMessageText():void {
    this.messageText = null;
  }

  // Returns true if field messageText is set (has been assigned a value) and false otherwise
  public function isSetMessageText():Boolean {
    return this.messageText != null;
  }

  public function get recipients():Array {
    return this._recipients;
  }

  public function set recipients(recipients:Array):void {
    this._recipients = recipients;
  }

  public function unsetRecipients():void {
    this.recipients = null;
  }

  // Returns true if field recipients is set (has been assigned a value) and false otherwise
  public function isSetRecipients():Boolean {
    return this.recipients != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case NOTEBOOKGUID:
      if (value == null) {
        unsetNotebookGuid();
      } else {
        this.notebookGuid = value;
      }
      break;

    case MESSAGETEXT:
      if (value == null) {
        unsetMessageText();
      } else {
        this.messageText = value;
      }
      break;

    case RECIPIENTS:
      if (value == null) {
        unsetRecipients();
      } else {
        this.recipients = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case NOTEBOOKGUID:
      return this.notebookGuid;
    case MESSAGETEXT:
      return this.messageText;
    case RECIPIENTS:
      return this.recipients;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case NOTEBOOKGUID:
      return isSetNotebookGuid();
    case MESSAGETEXT:
      return isSetMessageText();
    case RECIPIENTS:
      return isSetRecipients();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEBOOKGUID:
          if (field.type == TType.STRING) {
            this.notebookGuid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case MESSAGETEXT:
          if (field.type == TType.STRING) {
            this.messageText = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case RECIPIENTS:
          if (field.type == TType.LIST) {
            {
              var _list1129:TList = iprot.readListBegin();
              this.recipients = new Array();
              for (var _i1130:int = 0; _i1130 < _list1129.size; ++_i1130)
              {
                var _elem1131:String;
                _elem1131 = iprot.readString();
                this.recipients.push(_elem1131);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.notebookGuid != null) {
      oprot.writeFieldBegin(NOTEBOOK_GUID_FIELD_DESC);
      oprot.writeString(this.notebookGuid);
      oprot.writeFieldEnd();
    }
    if (this.messageText != null) {
      oprot.writeFieldBegin(MESSAGE_TEXT_FIELD_DESC);
      oprot.writeString(this.messageText);
      oprot.writeFieldEnd();
    }
    if (this.recipients != null) {
      oprot.writeFieldBegin(RECIPIENTS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.recipients.length));
        for each (var elem1132:* in this.recipients)        {
          oprot.writeString(elem1132);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("sendMessageToSharedNotebookMembers_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notebookGuid:";
    if (this.notebookGuid == null) {
      ret += "null";
    } else {
      ret += this.notebookGuid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "messageText:";
    if (this.messageText == null) {
      ret += "null";
    } else {
      ret += this.messageText;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "recipients:";
    if (this.recipients == null) {
      ret += "null";
    } else {
      ret += this.recipients;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class sendMessageToSharedNotebookMembers_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("sendMessageToSharedNotebookMembers_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(sendMessageToSharedNotebookMembers_result, metaDataMap);
  }

  public function sendMessageToSharedNotebookMembers_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("sendMessageToSharedNotebookMembers_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listSharedNotebooks_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listSharedNotebooks_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(listSharedNotebooks_args, metaDataMap);
  }

  public function listSharedNotebooks_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listSharedNotebooks_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listSharedNotebooks_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listSharedNotebooks_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, SharedNotebook)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(listSharedNotebooks_result, metaDataMap);
  }

  public function listSharedNotebooks_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list1142:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i1143:int = 0; _i1143 < _list1142.size; ++_i1143)
              {
                var _elem1144:SharedNotebook;
                _elem1144 = new SharedNotebook();
                _elem1144.read(iprot);
                this.success.push(_elem1144);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem1145:* in this.success)        {
          elem1145.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listSharedNotebooks_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeSharedNotebooks_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeSharedNotebooks_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const SHARED_NOTEBOOK_IDS_FIELD_DESC:TField = new TField("sharedNotebookIds", TType.LIST, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _sharedNotebookIds:Array;
  public static const SHAREDNOTEBOOKIDS:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SHAREDNOTEBOOKIDS] = new FieldMetaData("sharedNotebookIds", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.I64)));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeSharedNotebooks_args, metaDataMap);
  }

  public function expungeSharedNotebooks_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get sharedNotebookIds():Array {
    return this._sharedNotebookIds;
  }

  public function set sharedNotebookIds(sharedNotebookIds:Array):void {
    this._sharedNotebookIds = sharedNotebookIds;
  }

  public function unsetSharedNotebookIds():void {
    this.sharedNotebookIds = null;
  }

  // Returns true if field sharedNotebookIds is set (has been assigned a value) and false otherwise
  public function isSetSharedNotebookIds():Boolean {
    return this.sharedNotebookIds != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case SHAREDNOTEBOOKIDS:
      if (value == null) {
        unsetSharedNotebookIds();
      } else {
        this.sharedNotebookIds = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case SHAREDNOTEBOOKIDS:
      return this.sharedNotebookIds;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case SHAREDNOTEBOOKIDS:
      return isSetSharedNotebookIds();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SHAREDNOTEBOOKIDS:
          if (field.type == TType.LIST) {
            {
              var _list1148:TList = iprot.readListBegin();
              this.sharedNotebookIds = new Array();
              for (var _i1149:int = 0; _i1149 < _list1148.size; ++_i1149)
              {
                var _elem1150:BigInteger;
                _elem1150 = iprot.readI64();
                this.sharedNotebookIds.push(_elem1150);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.sharedNotebookIds != null) {
      oprot.writeFieldBegin(SHARED_NOTEBOOK_IDS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.I64, this.sharedNotebookIds.length));
        for each (var elem1151:* in this.sharedNotebookIds)        {
          oprot.writeI64(elem1151);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeSharedNotebooks_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "sharedNotebookIds:";
    if (this.sharedNotebookIds == null) {
      ret += "null";
    } else {
      ret += this.sharedNotebookIds;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeSharedNotebooks_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeSharedNotebooks_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeSharedNotebooks_result, metaDataMap);
  }

  public function expungeSharedNotebooks_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeSharedNotebooks_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createLinkedNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createLinkedNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const LINKED_NOTEBOOK_FIELD_DESC:TField = new TField("linkedNotebook", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _linkedNotebook:LinkedNotebook;
  public static const LINKEDNOTEBOOK:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[LINKEDNOTEBOOK] = new FieldMetaData("linkedNotebook", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, LinkedNotebook));
  }
  {
    FieldMetaData.addStructMetaDataMap(createLinkedNotebook_args, metaDataMap);
  }

  public function createLinkedNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get linkedNotebook():LinkedNotebook {
    return this._linkedNotebook;
  }

  public function set linkedNotebook(linkedNotebook:LinkedNotebook):void {
    this._linkedNotebook = linkedNotebook;
  }

  public function unsetLinkedNotebook():void {
    this.linkedNotebook = null;
  }

  // Returns true if field linkedNotebook is set (has been assigned a value) and false otherwise
  public function isSetLinkedNotebook():Boolean {
    return this.linkedNotebook != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case LINKEDNOTEBOOK:
      if (value == null) {
        unsetLinkedNotebook();
      } else {
        this.linkedNotebook = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case LINKEDNOTEBOOK:
      return this.linkedNotebook;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case LINKEDNOTEBOOK:
      return isSetLinkedNotebook();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LINKEDNOTEBOOK:
          if (field.type == TType.STRUCT) {
            this.linkedNotebook = new LinkedNotebook();
            this.linkedNotebook.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.linkedNotebook != null) {
      oprot.writeFieldBegin(LINKED_NOTEBOOK_FIELD_DESC);
      this.linkedNotebook.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createLinkedNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "linkedNotebook:";
    if (this.linkedNotebook == null) {
      ret += "null";
    } else {
      ret += this.linkedNotebook;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class createLinkedNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("createLinkedNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:LinkedNotebook;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, LinkedNotebook));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(createLinkedNotebook_result, metaDataMap);
  }

  public function createLinkedNotebook_result() {
  }

  public function get success():LinkedNotebook {
    return this._success;
  }

  public function set success(success:LinkedNotebook):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new LinkedNotebook();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("createLinkedNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateLinkedNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateLinkedNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const LINKED_NOTEBOOK_FIELD_DESC:TField = new TField("linkedNotebook", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _linkedNotebook:LinkedNotebook;
  public static const LINKEDNOTEBOOK:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[LINKEDNOTEBOOK] = new FieldMetaData("linkedNotebook", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, LinkedNotebook));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateLinkedNotebook_args, metaDataMap);
  }

  public function updateLinkedNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get linkedNotebook():LinkedNotebook {
    return this._linkedNotebook;
  }

  public function set linkedNotebook(linkedNotebook:LinkedNotebook):void {
    this._linkedNotebook = linkedNotebook;
  }

  public function unsetLinkedNotebook():void {
    this.linkedNotebook = null;
  }

  // Returns true if field linkedNotebook is set (has been assigned a value) and false otherwise
  public function isSetLinkedNotebook():Boolean {
    return this.linkedNotebook != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case LINKEDNOTEBOOK:
      if (value == null) {
        unsetLinkedNotebook();
      } else {
        this.linkedNotebook = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case LINKEDNOTEBOOK:
      return this.linkedNotebook;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case LINKEDNOTEBOOK:
      return isSetLinkedNotebook();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case LINKEDNOTEBOOK:
          if (field.type == TType.STRUCT) {
            this.linkedNotebook = new LinkedNotebook();
            this.linkedNotebook.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.linkedNotebook != null) {
      oprot.writeFieldBegin(LINKED_NOTEBOOK_FIELD_DESC);
      this.linkedNotebook.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateLinkedNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "linkedNotebook:";
    if (this.linkedNotebook == null) {
      ret += "null";
    } else {
      ret += this.linkedNotebook;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class updateLinkedNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("updateLinkedNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(updateLinkedNotebook_result, metaDataMap);
  }

  public function updateLinkedNotebook_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("updateLinkedNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listLinkedNotebooks_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listLinkedNotebooks_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(listLinkedNotebooks_args, metaDataMap);
  }

  public function listLinkedNotebooks_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listLinkedNotebooks_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class listLinkedNotebooks_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("listLinkedNotebooks_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new StructMetaData(TType.STRUCT, LinkedNotebook)));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(listLinkedNotebooks_result, metaDataMap);
  }

  public function listLinkedNotebooks_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list1173:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i1174:int = 0; _i1174 < _list1173.size; ++_i1174)
              {
                var _elem1175:LinkedNotebook;
                _elem1175 = new LinkedNotebook();
                _elem1175.read(iprot);
                this.success.push(_elem1175);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRUCT, this.success.length));
        for each (var elem1176:* in this.success)        {
          elem1176.write(oprot);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("listLinkedNotebooks_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeLinkedNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeLinkedNotebook_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeLinkedNotebook_args, metaDataMap);
  }

  public function expungeLinkedNotebook_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeLinkedNotebook_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class expungeLinkedNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("expungeLinkedNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(expungeLinkedNotebook_result, metaDataMap);
  }

  public function expungeLinkedNotebook_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("expungeLinkedNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class authenticateToSharedNotebook_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("authenticateToSharedNotebook_args");
  private static const SHARE_KEY_FIELD_DESC:TField = new TField("shareKey", TType.STRING, 1);
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 2);

  private var _shareKey:String;
  public static const SHAREKEY:int = 1;
  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SHAREKEY] = new FieldMetaData("shareKey", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(authenticateToSharedNotebook_args, metaDataMap);
  }

  public function authenticateToSharedNotebook_args() {
  }

  public function get shareKey():String {
    return this._shareKey;
  }

  public function set shareKey(shareKey:String):void {
    this._shareKey = shareKey;
  }

  public function unsetShareKey():void {
    this.shareKey = null;
  }

  // Returns true if field shareKey is set (has been assigned a value) and false otherwise
  public function isSetShareKey():Boolean {
    return this.shareKey != null;
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SHAREKEY:
      if (value == null) {
        unsetShareKey();
      } else {
        this.shareKey = value;
      }
      break;

    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SHAREKEY:
      return this.shareKey;
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SHAREKEY:
      return isSetShareKey();
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SHAREKEY:
          if (field.type == TType.STRING) {
            this.shareKey = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.shareKey != null) {
      oprot.writeFieldBegin(SHARE_KEY_FIELD_DESC);
      oprot.writeString(this.shareKey);
      oprot.writeFieldEnd();
    }
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("authenticateToSharedNotebook_args(");
    var first:Boolean = true;

    ret += "shareKey:";
    if (this.shareKey == null) {
      ret += "null";
    } else {
      ret += this.shareKey;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class authenticateToSharedNotebook_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("authenticateToSharedNotebook_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:AuthenticationResult;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, AuthenticationResult));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(authenticateToSharedNotebook_result, metaDataMap);
  }

  public function authenticateToSharedNotebook_result() {
  }

  public function get success():AuthenticationResult {
    return this._success;
  }

  public function set success(success:AuthenticationResult):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AuthenticationResult();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("authenticateToSharedNotebook_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSharedNotebookByAuth_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSharedNotebookByAuth_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSharedNotebookByAuth_args, metaDataMap);
  }

  public function getSharedNotebookByAuth_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSharedNotebookByAuth_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getSharedNotebookByAuth_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getSharedNotebookByAuth_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:SharedNotebook;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, SharedNotebook));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getSharedNotebookByAuth_result, metaDataMap);
  }

  public function getSharedNotebookByAuth_result() {
  }

  public function get success():SharedNotebook {
    return this._success;
  }

  public function set success(success:SharedNotebook):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new SharedNotebook();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getSharedNotebookByAuth_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class emailNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("emailNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const PARAMETERS_FIELD_DESC:TField = new TField("parameters", TType.STRUCT, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _parameters:NoteEmailParameters;
  public static const PARAMETERS:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[PARAMETERS] = new FieldMetaData("parameters", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, NoteEmailParameters));
  }
  {
    FieldMetaData.addStructMetaDataMap(emailNote_args, metaDataMap);
  }

  public function emailNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get parameters():NoteEmailParameters {
    return this._parameters;
  }

  public function set parameters(parameters:NoteEmailParameters):void {
    this._parameters = parameters;
  }

  public function unsetParameters():void {
    this.parameters = null;
  }

  // Returns true if field parameters is set (has been assigned a value) and false otherwise
  public function isSetParameters():Boolean {
    return this.parameters != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case PARAMETERS:
      if (value == null) {
        unsetParameters();
      } else {
        this.parameters = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case PARAMETERS:
      return this.parameters;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case PARAMETERS:
      return isSetParameters();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PARAMETERS:
          if (field.type == TType.STRUCT) {
            this.parameters = new NoteEmailParameters();
            this.parameters.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.parameters != null) {
      oprot.writeFieldBegin(PARAMETERS_FIELD_DESC);
      this.parameters.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("emailNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "parameters:";
    if (this.parameters == null) {
      ret += "null";
    } else {
      ret += this.parameters;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class emailNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("emailNote_result");
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(emailNote_result, metaDataMap);
  }

  public function emailNote_result() {
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("emailNote_result(");
    var first:Boolean = true;

    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class shareNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("shareNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(shareNote_args, metaDataMap);
  }

  public function shareNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("shareNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class shareNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("shareNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(shareNote_result, metaDataMap);
  }

  public function shareNote_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("shareNote_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class stopSharingNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("stopSharingNote_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 2);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;
  private var _guid:String;
  public static const GUID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(stopSharingNote_args, metaDataMap);
  }

  public function stopSharingNote_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    case GUID:
      return this.guid;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    case GUID:
      return isSetGuid();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("stopSharingNote_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class stopSharingNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("stopSharingNote_result");
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(stopSharingNote_result, metaDataMap);
  }

  public function stopSharingNote_result() {
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("stopSharingNote_result(");
    var first:Boolean = true;

    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class authenticateToSharedNote_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("authenticateToSharedNote_args");
  private static const GUID_FIELD_DESC:TField = new TField("guid", TType.STRING, 1);
  private static const NOTE_KEY_FIELD_DESC:TField = new TField("noteKey", TType.STRING, 2);

  private var _guid:String;
  public static const GUID:int = 1;
  private var _noteKey:String;
  public static const NOTEKEY:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[GUID] = new FieldMetaData("guid", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[NOTEKEY] = new FieldMetaData("noteKey", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(authenticateToSharedNote_args, metaDataMap);
  }

  public function authenticateToSharedNote_args() {
  }

  public function get guid():String {
    return this._guid;
  }

  public function set guid(guid:String):void {
    this._guid = guid;
  }

  public function unsetGuid():void {
    this.guid = null;
  }

  // Returns true if field guid is set (has been assigned a value) and false otherwise
  public function isSetGuid():Boolean {
    return this.guid != null;
  }

  public function get noteKey():String {
    return this._noteKey;
  }

  public function set noteKey(noteKey:String):void {
    this._noteKey = noteKey;
  }

  public function unsetNoteKey():void {
    this.noteKey = null;
  }

  // Returns true if field noteKey is set (has been assigned a value) and false otherwise
  public function isSetNoteKey():Boolean {
    return this.noteKey != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case GUID:
      if (value == null) {
        unsetGuid();
      } else {
        this.guid = value;
      }
      break;

    case NOTEKEY:
      if (value == null) {
        unsetNoteKey();
      } else {
        this.noteKey = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case GUID:
      return this.guid;
    case NOTEKEY:
      return this.noteKey;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case GUID:
      return isSetGuid();
    case NOTEKEY:
      return isSetNoteKey();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case GUID:
          if (field.type == TType.STRING) {
            this.guid = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTEKEY:
          if (field.type == TType.STRING) {
            this.noteKey = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.guid != null) {
      oprot.writeFieldBegin(GUID_FIELD_DESC);
      oprot.writeString(this.guid);
      oprot.writeFieldEnd();
    }
    if (this.noteKey != null) {
      oprot.writeFieldBegin(NOTE_KEY_FIELD_DESC);
      oprot.writeString(this.noteKey);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("authenticateToSharedNote_args(");
    var first:Boolean = true;

    ret += "guid:";
    if (this.guid == null) {
      ret += "null";
    } else {
      ret += this.guid;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "noteKey:";
    if (this.noteKey == null) {
      ret += "null";
    } else {
      ret += this.noteKey;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class authenticateToSharedNote_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("authenticateToSharedNote_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 2);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 3);

  private var _success:AuthenticationResult;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 2;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, AuthenticationResult));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(authenticateToSharedNote_result, metaDataMap);
  }

  public function authenticateToSharedNote_result() {
  }

  public function get success():AuthenticationResult {
    return this._success;
  }

  public function set success(success:AuthenticationResult):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AuthenticationResult();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("authenticateToSharedNote_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

