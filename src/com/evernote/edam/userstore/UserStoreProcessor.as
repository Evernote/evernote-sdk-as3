/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.evernote.edam.userstore {

import org.apache.thrift.Set;
import org.apache.thrift.type.BigInteger;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

import com.evernote.edam.error.EDAMUserException;
import com.evernote.edam.error.EDAMSystemException;
import com.evernote.edam.type.User;
import com.evernote.edam.error.EDAMNotFoundException;

  public class UserStoreProcessor implements TProcessor {
    public function UserStoreProcessor(iface:UserStore)
    {
      iface_ = iface;
      PROCESS_MAP["checkVersion"] = checkVersion();
      PROCESS_MAP["getBootstrapInfo"] = getBootstrapInfo();
      PROCESS_MAP["authenticate"] = authenticate();
      PROCESS_MAP["refreshAuthentication"] = refreshAuthentication();
      PROCESS_MAP["getUser"] = getUser();
      PROCESS_MAP["getPublicUserInfo"] = getPublicUserInfo();
      PROCESS_MAP["getPremiumInfo"] = getPremiumInfo();
      PROCESS_MAP["getNoteStoreUrl"] = getNoteStoreUrl();
    }

    private var iface_:UserStore;
    protected const PROCESS_MAP:Dictionary = new Dictionary();

    public function process(iprot:TProtocol, oprot:TProtocol):Boolean
    {
      var msg:TMessage = iprot.readMessageBegin();
      var fn:Function = PROCESS_MAP[msg.name];
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        var x:TApplicationError = new TApplicationError(TApplicationError.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.call(this,msg.seqid, iprot, oprot);
      return true;
    }

    private function checkVersion():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:checkVersion_args = new checkVersion_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:checkVersion_result = new checkVersion_result();
        // sorry this operation is not supported yet
        throw new Error("This is not yet supported");
        result.setSuccessIsSet(true);
        oprot.writeMessageBegin(new TMessage("checkVersion", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getBootstrapInfo():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getBootstrapInfo_args = new getBootstrapInfo_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getBootstrapInfo_result = new getBootstrapInfo_result();
        // sorry this operation is not supported yet
        throw new Error("This is not yet supported");
        oprot.writeMessageBegin(new TMessage("getBootstrapInfo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function authenticate():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:authenticate_args = new authenticate_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:authenticate_result = new authenticate_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing authenticate", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing authenticate");
          oprot.writeMessageBegin(new TMessage("authenticate", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("authenticate", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function refreshAuthentication():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:refreshAuthentication_args = new refreshAuthentication_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:refreshAuthentication_result = new refreshAuthentication_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing refreshAuthentication", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing refreshAuthentication");
          oprot.writeMessageBegin(new TMessage("refreshAuthentication", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("refreshAuthentication", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getUser():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getUser_args = new getUser_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getUser_result = new getUser_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getUser", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getUser");
          oprot.writeMessageBegin(new TMessage("getUser", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getUser", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getPublicUserInfo():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getPublicUserInfo_args = new getPublicUserInfo_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getPublicUserInfo_result = new getPublicUserInfo_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (notFoundException:EDAMNotFoundException) {
          result.notFoundException = notFoundException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (th:Error) {
          trace("Internal error processing getPublicUserInfo", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getPublicUserInfo");
          oprot.writeMessageBegin(new TMessage("getPublicUserInfo", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getPublicUserInfo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getPremiumInfo():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getPremiumInfo_args = new getPremiumInfo_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getPremiumInfo_result = new getPremiumInfo_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getPremiumInfo", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getPremiumInfo");
          oprot.writeMessageBegin(new TMessage("getPremiumInfo", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getPremiumInfo", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function getNoteStoreUrl():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:getNoteStoreUrl_args = new getNoteStoreUrl_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:getNoteStoreUrl_result = new getNoteStoreUrl_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (userException:EDAMUserException) {
          result.userException = userException;
        } catch (systemException:EDAMSystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing getNoteStoreUrl", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing getNoteStoreUrl");
          oprot.writeMessageBegin(new TMessage("getNoteStoreUrl", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getNoteStoreUrl", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

}
import org.apache.thrift.Set;
import org.apache.thrift.type.BigInteger;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

import com.evernote.edam.error.EDAMUserException;
import com.evernote.edam.error.EDAMSystemException;
import com.evernote.edam.type.User;
import com.evernote.edam.error.EDAMNotFoundException;

import com.evernote.edam.userstore.*;
class checkVersion_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("checkVersion_args");
  private static const CLIENT_NAME_FIELD_DESC:TField = new TField("clientName", TType.STRING, 1);
  private static const EDAM_VERSION_MAJOR_FIELD_DESC:TField = new TField("edamVersionMajor", TType.I16, 2);
  private static const EDAM_VERSION_MINOR_FIELD_DESC:TField = new TField("edamVersionMinor", TType.I16, 3);

  private var _clientName:String;
  public static const CLIENTNAME:int = 1;
  private var _edamVersionMajor:int;
  public static const EDAMVERSIONMAJOR:int = 2;
  private var _edamVersionMinor:int;
  public static const EDAMVERSIONMINOR:int = 3;

  private var __isset_edamVersionMajor:Boolean = false;
  private var __isset_edamVersionMinor:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[CLIENTNAME] = new FieldMetaData("clientName", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[EDAMVERSIONMAJOR] = new FieldMetaData("edamVersionMajor", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I16));
    metaDataMap[EDAMVERSIONMINOR] = new FieldMetaData("edamVersionMinor", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I16));
  }
  {
    FieldMetaData.addStructMetaDataMap(checkVersion_args, metaDataMap);
  }

  public function checkVersion_args() {
    this.edamVersionMajor = 1;

    this.edamVersionMinor = 21;

  }

  public function get clientName():String {
    return this._clientName;
  }

  public function set clientName(clientName:String):void {
    this._clientName = clientName;
  }

  public function unsetClientName():void {
    this.clientName = null;
  }

  // Returns true if field clientName is set (has been assigned a value) and false otherwise
  public function isSetClientName():Boolean {
    return this.clientName != null;
  }

  public function get edamVersionMajor():int {
    return this._edamVersionMajor;
  }

  public function set edamVersionMajor(edamVersionMajor:int):void {
    this._edamVersionMajor = edamVersionMajor;
    this.__isset_edamVersionMajor = true;
  }

  public function unsetEdamVersionMajor():void {
    this.__isset_edamVersionMajor = false;
  }

  // Returns true if field edamVersionMajor is set (has been assigned a value) and false otherwise
  public function isSetEdamVersionMajor():Boolean {
    return this.__isset_edamVersionMajor;
  }

  public function get edamVersionMinor():int {
    return this._edamVersionMinor;
  }

  public function set edamVersionMinor(edamVersionMinor:int):void {
    this._edamVersionMinor = edamVersionMinor;
    this.__isset_edamVersionMinor = true;
  }

  public function unsetEdamVersionMinor():void {
    this.__isset_edamVersionMinor = false;
  }

  // Returns true if field edamVersionMinor is set (has been assigned a value) and false otherwise
  public function isSetEdamVersionMinor():Boolean {
    return this.__isset_edamVersionMinor;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case CLIENTNAME:
      if (value == null) {
        unsetClientName();
      } else {
        this.clientName = value;
      }
      break;

    case EDAMVERSIONMAJOR:
      if (value == null) {
        unsetEdamVersionMajor();
      } else {
        this.edamVersionMajor = value;
      }
      break;

    case EDAMVERSIONMINOR:
      if (value == null) {
        unsetEdamVersionMinor();
      } else {
        this.edamVersionMinor = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case CLIENTNAME:
      return this.clientName;
    case EDAMVERSIONMAJOR:
      return this.edamVersionMajor;
    case EDAMVERSIONMINOR:
      return this.edamVersionMinor;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case CLIENTNAME:
      return isSetClientName();
    case EDAMVERSIONMAJOR:
      return isSetEdamVersionMajor();
    case EDAMVERSIONMINOR:
      return isSetEdamVersionMinor();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case CLIENTNAME:
          if (field.type == TType.STRING) {
            this.clientName = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EDAMVERSIONMAJOR:
          if (field.type == TType.I16) {
            this.edamVersionMajor = iprot.readI16();
            this.__isset_edamVersionMajor = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case EDAMVERSIONMINOR:
          if (field.type == TType.I16) {
            this.edamVersionMinor = iprot.readI16();
            this.__isset_edamVersionMinor = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.clientName != null) {
      oprot.writeFieldBegin(CLIENT_NAME_FIELD_DESC);
      oprot.writeString(this.clientName);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(EDAM_VERSION_MAJOR_FIELD_DESC);
    oprot.writeI16(this.edamVersionMajor);
    oprot.writeFieldEnd();
    oprot.writeFieldBegin(EDAM_VERSION_MINOR_FIELD_DESC);
    oprot.writeI16(this.edamVersionMinor);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("checkVersion_args(");
    var first:Boolean = true;

    ret += "clientName:";
    if (this.clientName == null) {
      ret += "null";
    } else {
      ret += this.clientName;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "edamVersionMajor:";
    ret += this.edamVersionMajor;
    first = false;
    if (!first) ret +=  ", ";
    ret += "edamVersionMinor:";
    ret += this.edamVersionMinor;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class checkVersion_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("checkVersion_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.BOOL, 0);

  private var _success:Boolean;
  public static const SUCCESS:int = 0;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.BOOL));
  }
  {
    FieldMetaData.addStructMetaDataMap(checkVersion_result, metaDataMap);
  }

  public function checkVersion_result() {
  }

  public function get success():Boolean {
    return this._success;
  }

  public function set success(success:Boolean):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.BOOL) {
            this.success = iprot.readBool();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeBool(this.success);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("checkVersion_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBootstrapInfo_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getBootstrapInfo_args");
  private static const LOCALE_FIELD_DESC:TField = new TField("locale", TType.STRING, 1);

  private var _locale:String;
  public static const LOCALE:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[LOCALE] = new FieldMetaData("locale", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getBootstrapInfo_args, metaDataMap);
  }

  public function getBootstrapInfo_args() {
  }

  public function get locale():String {
    return this._locale;
  }

  public function set locale(locale:String):void {
    this._locale = locale;
  }

  public function unsetLocale():void {
    this.locale = null;
  }

  // Returns true if field locale is set (has been assigned a value) and false otherwise
  public function isSetLocale():Boolean {
    return this.locale != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case LOCALE:
      if (value == null) {
        unsetLocale();
      } else {
        this.locale = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case LOCALE:
      return this.locale;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case LOCALE:
      return isSetLocale();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case LOCALE:
          if (field.type == TType.STRING) {
            this.locale = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.locale != null) {
      oprot.writeFieldBegin(LOCALE_FIELD_DESC);
      oprot.writeString(this.locale);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getBootstrapInfo_args(");
    var first:Boolean = true;

    ret += "locale:";
    if (this.locale == null) {
      ret += "null";
    } else {
      ret += this.locale;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getBootstrapInfo_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getBootstrapInfo_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);

  private var _success:BootstrapInfo;
  public static const SUCCESS:int = 0;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, BootstrapInfo));
  }
  {
    FieldMetaData.addStructMetaDataMap(getBootstrapInfo_result, metaDataMap);
  }

  public function getBootstrapInfo_result() {
  }

  public function get success():BootstrapInfo {
    return this._success;
  }

  public function set success(success:BootstrapInfo):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new BootstrapInfo();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getBootstrapInfo_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class authenticate_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("authenticate_args");
  private static const USERNAME_FIELD_DESC:TField = new TField("username", TType.STRING, 1);
  private static const PASSWORD_FIELD_DESC:TField = new TField("password", TType.STRING, 2);
  private static const CONSUMER_KEY_FIELD_DESC:TField = new TField("consumerKey", TType.STRING, 3);
  private static const CONSUMER_SECRET_FIELD_DESC:TField = new TField("consumerSecret", TType.STRING, 4);

  private var _username:String;
  public static const USERNAME:int = 1;
  private var _password:String;
  public static const PASSWORD:int = 2;
  private var _consumerKey:String;
  public static const CONSUMERKEY:int = 3;
  private var _consumerSecret:String;
  public static const CONSUMERSECRET:int = 4;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[USERNAME] = new FieldMetaData("username", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[PASSWORD] = new FieldMetaData("password", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[CONSUMERKEY] = new FieldMetaData("consumerKey", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[CONSUMERSECRET] = new FieldMetaData("consumerSecret", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(authenticate_args, metaDataMap);
  }

  public function authenticate_args() {
  }

  public function get username():String {
    return this._username;
  }

  public function set username(username:String):void {
    this._username = username;
  }

  public function unsetUsername():void {
    this.username = null;
  }

  // Returns true if field username is set (has been assigned a value) and false otherwise
  public function isSetUsername():Boolean {
    return this.username != null;
  }

  public function get password():String {
    return this._password;
  }

  public function set password(password:String):void {
    this._password = password;
  }

  public function unsetPassword():void {
    this.password = null;
  }

  // Returns true if field password is set (has been assigned a value) and false otherwise
  public function isSetPassword():Boolean {
    return this.password != null;
  }

  public function get consumerKey():String {
    return this._consumerKey;
  }

  public function set consumerKey(consumerKey:String):void {
    this._consumerKey = consumerKey;
  }

  public function unsetConsumerKey():void {
    this.consumerKey = null;
  }

  // Returns true if field consumerKey is set (has been assigned a value) and false otherwise
  public function isSetConsumerKey():Boolean {
    return this.consumerKey != null;
  }

  public function get consumerSecret():String {
    return this._consumerSecret;
  }

  public function set consumerSecret(consumerSecret:String):void {
    this._consumerSecret = consumerSecret;
  }

  public function unsetConsumerSecret():void {
    this.consumerSecret = null;
  }

  // Returns true if field consumerSecret is set (has been assigned a value) and false otherwise
  public function isSetConsumerSecret():Boolean {
    return this.consumerSecret != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case USERNAME:
      if (value == null) {
        unsetUsername();
      } else {
        this.username = value;
      }
      break;

    case PASSWORD:
      if (value == null) {
        unsetPassword();
      } else {
        this.password = value;
      }
      break;

    case CONSUMERKEY:
      if (value == null) {
        unsetConsumerKey();
      } else {
        this.consumerKey = value;
      }
      break;

    case CONSUMERSECRET:
      if (value == null) {
        unsetConsumerSecret();
      } else {
        this.consumerSecret = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case USERNAME:
      return this.username;
    case PASSWORD:
      return this.password;
    case CONSUMERKEY:
      return this.consumerKey;
    case CONSUMERSECRET:
      return this.consumerSecret;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case USERNAME:
      return isSetUsername();
    case PASSWORD:
      return isSetPassword();
    case CONSUMERKEY:
      return isSetConsumerKey();
    case CONSUMERSECRET:
      return isSetConsumerSecret();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case USERNAME:
          if (field.type == TType.STRING) {
            this.username = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PASSWORD:
          if (field.type == TType.STRING) {
            this.password = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONSUMERKEY:
          if (field.type == TType.STRING) {
            this.consumerKey = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case CONSUMERSECRET:
          if (field.type == TType.STRING) {
            this.consumerSecret = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.username != null) {
      oprot.writeFieldBegin(USERNAME_FIELD_DESC);
      oprot.writeString(this.username);
      oprot.writeFieldEnd();
    }
    if (this.password != null) {
      oprot.writeFieldBegin(PASSWORD_FIELD_DESC);
      oprot.writeString(this.password);
      oprot.writeFieldEnd();
    }
    if (this.consumerKey != null) {
      oprot.writeFieldBegin(CONSUMER_KEY_FIELD_DESC);
      oprot.writeString(this.consumerKey);
      oprot.writeFieldEnd();
    }
    if (this.consumerSecret != null) {
      oprot.writeFieldBegin(CONSUMER_SECRET_FIELD_DESC);
      oprot.writeString(this.consumerSecret);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("authenticate_args(");
    var first:Boolean = true;

    ret += "username:";
    if (this.username == null) {
      ret += "null";
    } else {
      ret += this.username;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "password:";
    if (this.password == null) {
      ret += "null";
    } else {
      ret += this.password;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "consumerKey:";
    if (this.consumerKey == null) {
      ret += "null";
    } else {
      ret += this.consumerKey;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "consumerSecret:";
    if (this.consumerSecret == null) {
      ret += "null";
    } else {
      ret += this.consumerSecret;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class authenticate_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("authenticate_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:AuthenticationResult;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, AuthenticationResult));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(authenticate_result, metaDataMap);
  }

  public function authenticate_result() {
  }

  public function get success():AuthenticationResult {
    return this._success;
  }

  public function set success(success:AuthenticationResult):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AuthenticationResult();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("authenticate_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class refreshAuthentication_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("refreshAuthentication_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(refreshAuthentication_args, metaDataMap);
  }

  public function refreshAuthentication_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("refreshAuthentication_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class refreshAuthentication_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("refreshAuthentication_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:AuthenticationResult;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, AuthenticationResult));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(refreshAuthentication_result, metaDataMap);
  }

  public function refreshAuthentication_result() {
  }

  public function get success():AuthenticationResult {
    return this._success;
  }

  public function set success(success:AuthenticationResult):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new AuthenticationResult();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("refreshAuthentication_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUser_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getUser_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getUser_args, metaDataMap);
  }

  public function getUser_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getUser_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getUser_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getUser_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:User;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, User));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getUser_result, metaDataMap);
  }

  public function getUser_result() {
  }

  public function get success():User {
    return this._success;
  }

  public function set success(success:User):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new User();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getUser_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPublicUserInfo_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getPublicUserInfo_args");
  private static const USERNAME_FIELD_DESC:TField = new TField("username", TType.STRING, 1);

  private var _username:String;
  public static const USERNAME:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[USERNAME] = new FieldMetaData("username", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getPublicUserInfo_args, metaDataMap);
  }

  public function getPublicUserInfo_args() {
  }

  public function get username():String {
    return this._username;
  }

  public function set username(username:String):void {
    this._username = username;
  }

  public function unsetUsername():void {
    this.username = null;
  }

  // Returns true if field username is set (has been assigned a value) and false otherwise
  public function isSetUsername():Boolean {
    return this.username != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case USERNAME:
      if (value == null) {
        unsetUsername();
      } else {
        this.username = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case USERNAME:
      return this.username;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case USERNAME:
      return isSetUsername();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case USERNAME:
          if (field.type == TType.STRING) {
            this.username = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.username != null) {
      oprot.writeFieldBegin(USERNAME_FIELD_DESC);
      oprot.writeString(this.username);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getPublicUserInfo_args(");
    var first:Boolean = true;

    ret += "username:";
    if (this.username == null) {
      ret += "null";
    } else {
      ret += this.username;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPublicUserInfo_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getPublicUserInfo_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const NOT_FOUND_EXCEPTION_FIELD_DESC:TField = new TField("notFoundException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 3);

  private var _success:PublicUserInfo;
  public static const SUCCESS:int = 0;
  private var _notFoundException:EDAMNotFoundException;
  public static const NOTFOUNDEXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, PublicUserInfo));
    metaDataMap[NOTFOUNDEXCEPTION] = new FieldMetaData("notFoundException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getPublicUserInfo_result, metaDataMap);
  }

  public function getPublicUserInfo_result() {
  }

  public function get success():PublicUserInfo {
    return this._success;
  }

  public function set success(success:PublicUserInfo):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get notFoundException():EDAMNotFoundException {
    return this._notFoundException;
  }

  public function set notFoundException(notFoundException:EDAMNotFoundException):void {
    this._notFoundException = notFoundException;
  }

  public function unsetNotFoundException():void {
    this.notFoundException = null;
  }

  // Returns true if field notFoundException is set (has been assigned a value) and false otherwise
  public function isSetNotFoundException():Boolean {
    return this.notFoundException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case NOTFOUNDEXCEPTION:
      if (value == null) {
        unsetNotFoundException();
      } else {
        this.notFoundException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case NOTFOUNDEXCEPTION:
      return this.notFoundException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    case USEREXCEPTION:
      return this.userException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case NOTFOUNDEXCEPTION:
      return isSetNotFoundException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    case USEREXCEPTION:
      return isSetUserException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PublicUserInfo();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case NOTFOUNDEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.notFoundException = new EDAMNotFoundException();
            this.notFoundException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetNotFoundException()) {
      oprot.writeFieldBegin(NOT_FOUND_EXCEPTION_FIELD_DESC);
      this.notFoundException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getPublicUserInfo_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "notFoundException:";
    if (this.notFoundException == null) {
      ret += "null";
    } else {
      ret += this.notFoundException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPremiumInfo_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getPremiumInfo_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getPremiumInfo_args, metaDataMap);
  }

  public function getPremiumInfo_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getPremiumInfo_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getPremiumInfo_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getPremiumInfo_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:PremiumInfo;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, PremiumInfo));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getPremiumInfo_result, metaDataMap);
  }

  public function getPremiumInfo_result() {
  }

  public function get success():PremiumInfo {
    return this._success;
  }

  public function set success(success:PremiumInfo):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new PremiumInfo();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getPremiumInfo_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteStoreUrl_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteStoreUrl_args");
  private static const AUTHENTICATION_TOKEN_FIELD_DESC:TField = new TField("authenticationToken", TType.STRING, 1);

  private var _authenticationToken:String;
  public static const AUTHENTICATIONTOKEN:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHENTICATIONTOKEN] = new FieldMetaData("authenticationToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteStoreUrl_args, metaDataMap);
  }

  public function getNoteStoreUrl_args() {
  }

  public function get authenticationToken():String {
    return this._authenticationToken;
  }

  public function set authenticationToken(authenticationToken:String):void {
    this._authenticationToken = authenticationToken;
  }

  public function unsetAuthenticationToken():void {
    this.authenticationToken = null;
  }

  // Returns true if field authenticationToken is set (has been assigned a value) and false otherwise
  public function isSetAuthenticationToken():Boolean {
    return this.authenticationToken != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      if (value == null) {
        unsetAuthenticationToken();
      } else {
        this.authenticationToken = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return this.authenticationToken;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHENTICATIONTOKEN:
      return isSetAuthenticationToken();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHENTICATIONTOKEN:
          if (field.type == TType.STRING) {
            this.authenticationToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authenticationToken != null) {
      oprot.writeFieldBegin(AUTHENTICATION_TOKEN_FIELD_DESC);
      oprot.writeString(this.authenticationToken);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteStoreUrl_args(");
    var first:Boolean = true;

    ret += "authenticationToken:";
    if (this.authenticationToken == null) {
      ret += "null";
    } else {
      ret += this.authenticationToken;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class getNoteStoreUrl_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("getNoteStoreUrl_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const USER_EXCEPTION_FIELD_DESC:TField = new TField("userException", TType.STRUCT, 1);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 2);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _userException:EDAMUserException;
  public static const USEREXCEPTION:int = 1;
  private var _systemException:EDAMSystemException;
  public static const SYSTEMEXCEPTION:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[USEREXCEPTION] = new FieldMetaData("userException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(getNoteStoreUrl_result, metaDataMap);
  }

  public function getNoteStoreUrl_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get userException():EDAMUserException {
    return this._userException;
  }

  public function set userException(userException:EDAMUserException):void {
    this._userException = userException;
  }

  public function unsetUserException():void {
    this.userException = null;
  }

  // Returns true if field userException is set (has been assigned a value) and false otherwise
  public function isSetUserException():Boolean {
    return this.userException != null;
  }

  public function get systemException():EDAMSystemException {
    return this._systemException;
  }

  public function set systemException(systemException:EDAMSystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case USEREXCEPTION:
      if (value == null) {
        unsetUserException();
      } else {
        this.userException = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case USEREXCEPTION:
      return this.userException;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case USEREXCEPTION:
      return isSetUserException();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case USEREXCEPTION:
          if (field.type == TType.STRUCT) {
            this.userException = new EDAMUserException();
            this.userException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new EDAMSystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetUserException()) {
      oprot.writeFieldBegin(USER_EXCEPTION_FIELD_DESC);
      this.userException.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("getNoteStoreUrl_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "userException:";
    if (this.userException == null) {
      ret += "null";
    } else {
      ret += this.userException;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

