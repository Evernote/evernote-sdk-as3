/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.evernote.edam.notestore {

import org.apache.thrift.Set;
import org.apache.thrift.type.BigInteger;
import flash.utils.ByteArray;
import flash.utils.Dictionary;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


  /**
   *  A list of criteria that are used to indicate which notes are desired from
   *  the account.  This is used in queries to the NoteStore to determine
   *  which notes should be retrieved.
   * 
   * <dl>
   *  <dt>order</dt>
   *    <dd>
   *    The NoteSortOrder value indicating what criterion should be
   *    used to sort the results of the filter.
   *    </dd>
   * 
   *  <dt>ascending</dt>
   *    <dd>
   *    If true, the results will be ascending in the requested
   *    sort order.  If false, the results will be descending.
   *    </dd>
   * 
   *  <dt>words</dt>
   *    <dd>
   *    If present, a search query string that will filter the set of notes to be returned.
   *    Accepts the full search grammar documented in the Evernote API Overview.
   *    </dd>
   * 
   *  <dt>notebookGuid</dt>
   *    <dd>
   *    If present, the Guid of the notebook that must contain
   *    the notes.
   *    </dd>
   * 
   *  <dt>tagGuids</dt>
   *    <dd>
   *    If present, the list of tags (by GUID) that must be present
   *    on the notes.
   *    </dd>
   * 
   *  <dt>timeZone</dt>
   *    <dd>
   *    The zone ID for the user, which will be used to interpret
   *    any dates or times in the queries that do not include their desired zone
   *    information.
   *    For example, if a query requests notes created "yesterday", this
   *    will be evaluated from the provided time zone, if provided.
   *    The format must be encoded as a standard zone ID such as
   *    "America/Los_Angeles".
   *    </dd>
   * 
   *  <dt>inactive</dt>
   *    <dd>
   *    If true, then only notes that are not active (i.e. notes in
   *    the Trash) will be returned. Otherwise, only active notes will be returned.
   *    There is no way to find both active and inactive notes in a single query.
   *    </dd>
   *  </dl>
   */
  public class NoteFilter implements TBase   {
    private static const STRUCT_DESC:TStruct = new TStruct("NoteFilter");
    private static const ORDER_FIELD_DESC:TField = new TField("order", TType.I32, 1);
    private static const ASCENDING_FIELD_DESC:TField = new TField("ascending", TType.BOOL, 2);
    private static const WORDS_FIELD_DESC:TField = new TField("words", TType.STRING, 3);
    private static const NOTEBOOK_GUID_FIELD_DESC:TField = new TField("notebookGuid", TType.STRING, 4);
    private static const TAG_GUIDS_FIELD_DESC:TField = new TField("tagGuids", TType.LIST, 5);
    private static const TIME_ZONE_FIELD_DESC:TField = new TField("timeZone", TType.STRING, 6);
    private static const INACTIVE_FIELD_DESC:TField = new TField("inactive", TType.BOOL, 7);

    private var _order:int;
    public static const ORDER:int = 1;
    private var _ascending:Boolean;
    public static const ASCENDING:int = 2;
    private var _words:String;
    public static const WORDS:int = 3;
    private var _notebookGuid:String;
    public static const NOTEBOOKGUID:int = 4;
    private var _tagGuids:Array;
    public static const TAGGUIDS:int = 5;
    private var _timeZone:String;
    public static const TIMEZONE:int = 6;
    private var _inactive:Boolean;
    public static const INACTIVE:int = 7;

    private var __isset_order:Boolean = false;
    private var __isset_ascending:Boolean = false;
    private var __isset_inactive:Boolean = false;

    public static const metaDataMap:Dictionary = new Dictionary();
    {
      metaDataMap[ORDER] = new FieldMetaData("order", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.I32));
      metaDataMap[ASCENDING] = new FieldMetaData("ascending", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.BOOL));
      metaDataMap[WORDS] = new FieldMetaData("words", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.STRING));
      metaDataMap[NOTEBOOKGUID] = new FieldMetaData("notebookGuid", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.STRING));
      metaDataMap[TAGGUIDS] = new FieldMetaData("tagGuids", TFieldRequirementType.OPTIONAL, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING)));
      metaDataMap[TIMEZONE] = new FieldMetaData("timeZone", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.STRING));
      metaDataMap[INACTIVE] = new FieldMetaData("inactive", TFieldRequirementType.OPTIONAL, 
          new FieldValueMetaData(TType.BOOL));
    }
    {
      FieldMetaData.addStructMetaDataMap(NoteFilter, metaDataMap);
    }

    public function NoteFilter() {
    }

    public function get order():int {
      return this._order;
    }

    public function set order(order:int):void {
      this._order = order;
      this.__isset_order = true;
    }

    public function unsetOrder():void {
      this.__isset_order = false;
    }

    // Returns true if field order is set (has been assigned a value) and false otherwise
    public function isSetOrder():Boolean {
      return this.__isset_order;
    }

    public function get ascending():Boolean {
      return this._ascending;
    }

    public function set ascending(ascending:Boolean):void {
      this._ascending = ascending;
      this.__isset_ascending = true;
    }

    public function unsetAscending():void {
      this.__isset_ascending = false;
    }

    // Returns true if field ascending is set (has been assigned a value) and false otherwise
    public function isSetAscending():Boolean {
      return this.__isset_ascending;
    }

    public function get words():String {
      return this._words;
    }

    public function set words(words:String):void {
      this._words = words;
    }

    public function unsetWords():void {
      this.words = null;
    }

    // Returns true if field words is set (has been assigned a value) and false otherwise
    public function isSetWords():Boolean {
      return this.words != null;
    }

    public function get notebookGuid():String {
      return this._notebookGuid;
    }

    public function set notebookGuid(notebookGuid:String):void {
      this._notebookGuid = notebookGuid;
    }

    public function unsetNotebookGuid():void {
      this.notebookGuid = null;
    }

    // Returns true if field notebookGuid is set (has been assigned a value) and false otherwise
    public function isSetNotebookGuid():Boolean {
      return this.notebookGuid != null;
    }

    public function get tagGuids():Array {
      return this._tagGuids;
    }

    public function set tagGuids(tagGuids:Array):void {
      this._tagGuids = tagGuids;
    }

    public function unsetTagGuids():void {
      this.tagGuids = null;
    }

    // Returns true if field tagGuids is set (has been assigned a value) and false otherwise
    public function isSetTagGuids():Boolean {
      return this.tagGuids != null;
    }

    public function get timeZone():String {
      return this._timeZone;
    }

    public function set timeZone(timeZone:String):void {
      this._timeZone = timeZone;
    }

    public function unsetTimeZone():void {
      this.timeZone = null;
    }

    // Returns true if field timeZone is set (has been assigned a value) and false otherwise
    public function isSetTimeZone():Boolean {
      return this.timeZone != null;
    }

    public function get inactive():Boolean {
      return this._inactive;
    }

    public function set inactive(inactive:Boolean):void {
      this._inactive = inactive;
      this.__isset_inactive = true;
    }

    public function unsetInactive():void {
      this.__isset_inactive = false;
    }

    // Returns true if field inactive is set (has been assigned a value) and false otherwise
    public function isSetInactive():Boolean {
      return this.__isset_inactive;
    }

    public function setFieldValue(fieldID:int, value:*):void {
      switch (fieldID) {
      case ORDER:
        if (value == null) {
          unsetOrder();
        } else {
          this.order = value;
        }
        break;

      case ASCENDING:
        if (value == null) {
          unsetAscending();
        } else {
          this.ascending = value;
        }
        break;

      case WORDS:
        if (value == null) {
          unsetWords();
        } else {
          this.words = value;
        }
        break;

      case NOTEBOOKGUID:
        if (value == null) {
          unsetNotebookGuid();
        } else {
          this.notebookGuid = value;
        }
        break;

      case TAGGUIDS:
        if (value == null) {
          unsetTagGuids();
        } else {
          this.tagGuids = value;
        }
        break;

      case TIMEZONE:
        if (value == null) {
          unsetTimeZone();
        } else {
          this.timeZone = value;
        }
        break;

      case INACTIVE:
        if (value == null) {
          unsetInactive();
        } else {
          this.inactive = value;
        }
        break;

      default:
        throw new ArgumentError("Field " + fieldID + " doesn't exist!");
      }
    }

    public function getFieldValue(fieldID:int):* {
      switch (fieldID) {
      case ORDER:
        return this.order;
      case ASCENDING:
        return this.ascending;
      case WORDS:
        return this.words;
      case NOTEBOOKGUID:
        return this.notebookGuid;
      case TAGGUIDS:
        return this.tagGuids;
      case TIMEZONE:
        return this.timeZone;
      case INACTIVE:
        return this.inactive;
      default:
        throw new ArgumentError("Field " + fieldID + " doesn't exist!");
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    public function isSet(fieldID:int):Boolean {
      switch (fieldID) {
      case ORDER:
        return isSetOrder();
      case ASCENDING:
        return isSetAscending();
      case WORDS:
        return isSetWords();
      case NOTEBOOKGUID:
        return isSetNotebookGuid();
      case TAGGUIDS:
        return isSetTagGuids();
      case TIMEZONE:
        return isSetTimeZone();
      case INACTIVE:
        return isSetInactive();
      default:
        throw new ArgumentError("Field " + fieldID + " doesn't exist!");
      }
    }

    public function read(iprot:TProtocol):void {
      var field:TField;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id)
        {
          case ORDER:
            if (field.type == TType.I32) {
              this.order = iprot.readI32();
              this.__isset_order = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case ASCENDING:
            if (field.type == TType.BOOL) {
              this.ascending = iprot.readBool();
              this.__isset_ascending = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case WORDS:
            if (field.type == TType.STRING) {
              this.words = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case NOTEBOOKGUID:
            if (field.type == TType.STRING) {
              this.notebookGuid = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TAGGUIDS:
            if (field.type == TType.LIST) {
              {
                var _list82:TList = iprot.readListBegin();
                this.tagGuids = new Array();
                for (var _i83:int = 0; _i83 < _list82.size; ++_i83)
                {
                  var _elem84:String;
                  _elem84 = iprot.readString();
                  this.tagGuids.push(_elem84);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case TIMEZONE:
            if (field.type == TType.STRING) {
              this.timeZone = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case INACTIVE:
            if (field.type == TType.BOOL) {
              this.inactive = iprot.readBool();
              this.__isset_inactive = true;
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
            break;
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();


      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public function write(oprot:TProtocol):void {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (isSetOrder()) {
        oprot.writeFieldBegin(ORDER_FIELD_DESC);
        oprot.writeI32(this.order);
        oprot.writeFieldEnd();
      }
      if (isSetAscending()) {
        oprot.writeFieldBegin(ASCENDING_FIELD_DESC);
        oprot.writeBool(this.ascending);
        oprot.writeFieldEnd();
      }
      if (this.words != null) {
        if (isSetWords()) {
          oprot.writeFieldBegin(WORDS_FIELD_DESC);
          oprot.writeString(this.words);
          oprot.writeFieldEnd();
        }
      }
      if (this.notebookGuid != null) {
        if (isSetNotebookGuid()) {
          oprot.writeFieldBegin(NOTEBOOK_GUID_FIELD_DESC);
          oprot.writeString(this.notebookGuid);
          oprot.writeFieldEnd();
        }
      }
      if (this.tagGuids != null) {
        if (isSetTagGuids()) {
          oprot.writeFieldBegin(TAG_GUIDS_FIELD_DESC);
          {
            oprot.writeListBegin(new TList(TType.STRING, this.tagGuids.length));
            for each (var elem85:* in this.tagGuids)            {
              oprot.writeString(elem85);
            }
            oprot.writeListEnd();
          }
          oprot.writeFieldEnd();
        }
      }
      if (this.timeZone != null) {
        if (isSetTimeZone()) {
          oprot.writeFieldBegin(TIME_ZONE_FIELD_DESC);
          oprot.writeString(this.timeZone);
          oprot.writeFieldEnd();
        }
      }
      if (isSetInactive()) {
        oprot.writeFieldBegin(INACTIVE_FIELD_DESC);
        oprot.writeBool(this.inactive);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    public function toString():String {
      var ret:String = new String("NoteFilter(");
      var first:Boolean = true;

      if (isSetOrder()) {
        ret += "order:";
        ret += this.order;
        first = false;
      }
      if (isSetAscending()) {
        if (!first) ret +=  ", ";
        ret += "ascending:";
        ret += this.ascending;
        first = false;
      }
      if (isSetWords()) {
        if (!first) ret +=  ", ";
        ret += "words:";
        if (this.words == null) {
          ret += "null";
        } else {
          ret += this.words;
        }
        first = false;
      }
      if (isSetNotebookGuid()) {
        if (!first) ret +=  ", ";
        ret += "notebookGuid:";
        if (this.notebookGuid == null) {
          ret += "null";
        } else {
          ret += this.notebookGuid;
        }
        first = false;
      }
      if (isSetTagGuids()) {
        if (!first) ret +=  ", ";
        ret += "tagGuids:";
        if (this.tagGuids == null) {
          ret += "null";
        } else {
          ret += this.tagGuids;
        }
        first = false;
      }
      if (isSetTimeZone()) {
        if (!first) ret +=  ", ";
        ret += "timeZone:";
        if (this.timeZone == null) {
          ret += "null";
        } else {
          ret += this.timeZone;
        }
        first = false;
      }
      if (isSetInactive()) {
        if (!first) ret +=  ", ";
        ret += "inactive:";
        ret += this.inactive;
        first = false;
      }
      ret += ")";
      return ret;
    }

    public function validate():void {
      // check for required fields
      // check that fields of type enum have valid values
    }

  }

}
